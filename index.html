<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handball Court Game</title>
    <style>
        /*
        Global Styling
        */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1e3a8a, #0c4a6e); /* Deep Blue Gradient */
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            background-color: #0d1a33; /* Dark background for score/info */
            position: relative; /* Needed for absolute positioning of overlay */
        }

        /*
        Canvas Styling
        */
        canvas {
            display: block;
            border: 4px solid #ffffff;
            border-radius: 10px;
            background-color: #22c55e; /* Vibrant Green Court */
            touch-action: none; /* Disable default touch actions */
            max-width: 95vw;
            max-height: 80vh;
        }

        /*
        Scoreboard and Info Styling
        */
        .scoreboard {
            display: flex;
            justify-content: space-between; 
            width: 100%;
            max-width: 800px;
            margin-bottom: 15px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .player-info {
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 150px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
            font-size: 1.5rem; 
        }

        #score-p1 { background-color: #ef4444; } /* Red */
        #score-p2 { background-color: #3b82f6; } /* Blue */
        
        .controls-info {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.9;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .controls-info strong {
            color: #fcd34d;
        }
        
        /* Reset Button Styling */
        .reset-button {
            background-color: #f59e0b; /* Amber */
            color: #0d1a33;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            align-self: center;
        }

        .reset-button:hover {
            background-color: #d97706; /* Darker amber */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
        }

        .reset-button:active {
            transform: scale(0.98);
        }

        /* Game Overlay Styling */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
            border-radius: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .overlay-content {
            padding: 30px;
            background: #1f2937;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }
        
        .overlay-content h2 {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .overlay-content p {
            font-size: 1.2rem;
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div class="game-container">
        
        <!-- Game State Overlay (Hidden by default) -->
        <div id="gameOverlay" class="game-overlay" style="display: none;">
            <div class="overlay-content">
                <h2 id="overlayTitle">PAUSED</h2>
                <p id="overlayMessage">Press ESC to Resume</p>
                <p id="overlayScore"></p>
            </div>
        </div>

        <!-- Scoreboard -->
        <div class="scoreboard">
            <div id="score-p1" class="player-info">P1 (Red): 0</div>
            <!-- Reset Button -->
            <button id="resetButton" class="reset-button">RESET GAME</button> 
            <div id="score-p2" class="player-info">P2 (Blue): 0</div>
        </div>

        <!-- Game Canvas -->
        <canvas id="handballCanvas" width="800" height="500"></canvas>

        <!-- Controls Information -->
        <div class="controls-info">
            <p><strong>Player 1 (Red):</strong> Move (W, A, S, D), Dash (Left Shift), Shield (X), Super Shot (Z), Lobe Shot (Q), **Slide Tackle (C)**.</p>
            <p><strong>Player 2 (Blue):</strong> Move (Arrows), Dash (Right Control), Shield (9), Super Shot (0), Lobe Shot (U), **Slide Tackle (/)**.</p>
            <p><strong>Deflection Block:</strong> Stand completely still (no movement) to reflect fast shots with extra power.</p>
            <p><strong>Momentum Pass:</strong> Move slowly to significantly reduce the ball's speed for precise setup.</p>
            <p><strong>Ball Catch:</strong> Stand completely still and allow the ball to hit you at low speed to stick the ball for a guaranteed setup.</p>
        </div>
    </div>

    <script>
        // Game Constants and Initialization
        const canvas = document.getElementById('handballCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('gameOverlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const overlayScore = document.getElementById('overlayScore');
        
        // Dimensions
        const COURT_WIDTH = 800; // Fixed internal logic size
        const COURT_HEIGHT = 500;
        const PLAYER_RADIUS = 20;
        const BALL_RADIUS = 12;
        const GOAL_WIDTH = 30;
        const GOAL_HEIGHT = 160;

        // Game Timing Constants
        const FPS = 60;
        const PAUSE_KEY = 'Escape';

        // Dash and Stun Constants
        const DASH_SPEED_MULTIPLIER = 2.5;
        const DASH_DURATION_FRAMES = 15; 
        const DASH_COOLDOWN_FRAMES = 180; 
        const STUN_DURATION_FRAMES = 30; 
        
        // Shield Constants
        const SHIELD_DURATION_FRAMES = 60; 
        const SHIELD_COOLDOWN_FRAMES = 360; 

        // Super Shot Constants
        const SS_MAX_METER = 100;
        const SS_CHARGE_PER_HIT = 5; 
        const SS_SHOT_MULTIPLIER = 30; 
        
        // NEW: Sticking/Catching Constants
        const STICK_SPEED_THRESHOLD = 0.5; // Player movement must be below this to catch
        const STICK_BALL_SPEED_MAX = 5.0; // Ball speed must be below this to be caught
        
        // NEW: Slide Tackle Constants
        const SLIDE_DURATION_FRAMES = 12;
        const SLIDE_COOLDOWN_FRAMES = 240; // Longer cooldown than dash
        const SLIDE_SPEED_MULTIPLIER = 3.5;
        const SLIDE_STUN_DURATION = 15; // Minor stun

        // Existing New Feature Constants
        const DEFLECTION_MULTIPLIER = 1.2; 
        const DEFLECTION_SPEED_THRESHOLD = 1.0; 
        const PASS_MAX_OUT_SPEED = 4.0; 
        const PASS_PLAYER_SPEED_MAX = 3.5; 
        
        // Other Constants (Powerup, Lobe, Sludge, Goalie Zone, Shake)
        const POWERUP_RADIUS = 15;
        const POWERUP_DURATION_FRAMES = 300; 
        const POWERUP_SPAWN_COOLDOWN = 600; 
        const GOALIE_ZONE_DEPTH = 150; 
        const GOALIE_SPEED_BONUS = 2; 
        const LOBE_VERTICAL_DAMPENING = 0.5; 
        const SLUDGE_ZONE_WIDTH = 30; 
        const SLUDGE_SPEED_MULTIPLIER = 0.5; 
        const SHAKE_DURATION_FRAMES = 30; 
        const SHAKE_INTENSITY = 8; 

        // Game State
        let score = { p1: 0, p2: 0 };
        let isGameRunning = false;
        let isPaused = false;
        let lastTime = 0;
        let lastTouchedBy = null; 
        let lastPlayerVelocity = { p1: 0, p2: 0 }; 
        let shakeDuration = 0;

        let powerup = { 
            x: 0, y: 0,
            active: false,
            durationTimer: 0,
            spawnTimer: 0
        };

        // Player Factory 
        const createPlayer = (x, y, color, keys, dashKey, shieldKey, ssKey, lobeKey, slideKey, isP1) => ({
            x, y,
            radius: PLAYER_RADIUS,
            color,
            baseColor: color,
            speed: 5,
            vx: 0,
            vy: 0,
            keys,
            dashKey,
            shieldKey,          
            ssKey,              
            lobeKey,   
            slideKey, // NEW
            dashTimer: 0,
            cooldownTimer: 0,
            stunTimer: 0,
            boostTimer: 0, 
            shieldTimer: 0,     
            shieldCooldown: 0,  
            ssMeter: 0,         
            ssActive: false,    
            slideTimer: 0, // NEW
            slideCooldown: 0, // NEW
            isHoldingBall: false, // NEW
            isP1
        });

        // --- Game Objects ---
        let player1 = createPlayer(
            COURT_WIDTH * 0.25, COURT_HEIGHT / 2, '#ef4444', 
            { up: 'w', down: 's', left: 'a', right: 'd' }, 
            'Shift', 'x', 'z', 'q', 'c', true // slide key 'c'
        );

        let player2 = createPlayer(
            COURT_WIDTH * 0.75, COURT_HEIGHT / 2, '#3b82f6', 
            { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, 
            'Control', '9', '0', 'u', '/', false // slide key '/'
        );

        let ball = {
            x: COURT_WIDTH / 2,
            y: COURT_HEIGHT / 2,
            radius: BALL_RADIUS,
            color: '#fcd34d',
            vx: 0,
            vy: 0,
            friction: 0.99,
            maxSpeed: 15,
            isLobbing: false,
            holder: null // NEW: player object holding the ball, or null
        };

        // Input
        let keysPressed = {};
        
        // --- Audio Context for simple sounds ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Simple Sound Generator (Beep)
        function playBeep(frequency = 440, duration = 0.1, volume = 0.5) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- Core Functions ---

        function setupGame() {
            // Event listeners for input
            window.addEventListener('keydown', (e) => { 
                keysPressed[e.key] = true; 
                if (e.key === PAUSE_KEY) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', (e) => { 
                keysPressed[e.key] = false; 
                // Ensure Super Shot key is only registered once per press
                if (e.key.toLowerCase() === player1.ssKey.toLowerCase()) player1.ssActive = false;
                if (e.key === player2.ssKey) player2.ssActive = false;
            });
            
            // Reset Button Listener
            document.getElementById('resetButton').addEventListener('click', resetGame);
            
            isGameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                overlayTitle.textContent = "PAUSED";
                overlayMessage.textContent = "Press ESC to Resume";
                overlayScore.textContent = "";
                overlay.style.display = 'flex';
                playBeep(220, 0.2, 0.5);
            } else {
                overlay.style.display = 'none';
                lastTime = performance.now();
            }
        }
        
        function resetGame() {
            score = { p1: 0, p2: 0 };
            lastTouchedBy = null;
            isPaused = false;
            isGameRunning = true;
            shakeDuration = 0;
            
            // Clear powerup
            powerup.active = false;
            powerup.spawnTimer = 0;
            
            // Reset players and ball position
            resetBall(null); 
            
            // Clear all active effects
            [player1, player2].forEach(p => {
                p.stunTimer = 0;
                p.dashTimer = 0;
                p.cooldownTimer = 0;
                p.boostTimer = 0;
                p.shieldTimer = 0;
                p.shieldCooldown = 0;
                p.ssMeter = 0;
                p.ssActive = false;
                p.slideTimer = 0; // NEW
                p.slideCooldown = 0; // NEW
                p.isHoldingBall = false; // NEW
                p.color = p.baseColor;
            });

            overlay.style.display = 'none';
            
            updateScoreboard();
            playBeep(440, 0.3, 0.7);
            
            if (isGameRunning) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        function resetBall(scorer) {
            ball.x = COURT_WIDTH / 2;
            ball.y = COURT_HEIGHT / 2;
            ball.vx = 0;
            ball.vy = 0;
            ball.isLobbing = false; 
            ball.holder = null; // NEW: Reset holder

            // Give a slight kick to the non-scorer
            if (scorer === player1) {
                ball.vx = 4;
            } else if (scorer === player2) {
                ball.vx = -4;
            }
            
            player1.x = COURT_WIDTH * 0.25;
            player1.y = COURT_HEIGHT / 2;
            player2.x = COURT_WIDTH * 0.75;
            player2.y = COURT_HEIGHT / 2;
            player1.vx = player1.vy = 0;
            player2.vx = player2.vy = 0;
            
            // Ensure no player is holding the ball
            player1.isHoldingBall = false;
            player2.isHoldingBall = false;
        }

        function updateScoreboard() {
            document.getElementById('score-p1').textContent = `P1 (Red): ${score.p1}`;
            document.getElementById('score-p2').textContent = `P2 (Blue): ${score.p2}`;
        }


        // --- Drawing ---

        function drawCourt() {
            // Draw Goalie Zones (visual aid)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, GOALIE_ZONE_DEPTH, COURT_HEIGHT); // Left Zone
            ctx.fillRect(COURT_WIDTH - GOALIE_ZONE_DEPTH, 0, GOALIE_ZONE_DEPTH, COURT_HEIGHT); // Right Zone
            
            // Draw Sludge Zones
            ctx.fillStyle = 'rgba(101, 67, 33, 0.5)'; // Muddy brown color
            ctx.fillRect(0, 0, COURT_WIDTH, SLUDGE_ZONE_WIDTH); // Top Sludge Zone
            ctx.fillRect(0, COURT_HEIGHT - SLUDGE_ZONE_WIDTH, COURT_WIDTH, COURT_HEIGHT); // Bottom Sludge Zone (Adjusted height)

            // Center Line and Circle
            ctx.beginPath();
            ctx.moveTo(COURT_WIDTH / 2, 0);
            ctx.lineTo(COURT_WIDTH / 2, COURT_HEIGHT);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.arc(COURT_WIDTH / 2, COURT_HEIGHT / 2, 50, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            // Goal Areas
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;

            // Left Goal Area (P1 Side)
            ctx.beginPath();
            ctx.rect(5, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();

            // Right Goal Area (P2 Side)
            ctx.beginPath();
            ctx.rect(COURT_WIDTH - 105, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();
        }
        
        // Draw possession indicator
        function drawPossessionIndicator(player) {
            if (lastTouchedBy === player) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI * 2);
                ctx.strokeStyle = '#fcd34d'; // Yellow/Gold color for possession
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]); // Shimmer effect
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
                ctx.closePath();
            }
        }
        
        // Draw Powerup
        function drawPowerup() {
            if (!powerup.active) return;
            
            ctx.beginPath();
            ctx.arc(powerup.x, powerup.y, POWERUP_RADIUS, 0, Math.PI * 2);
            
            // Pulsing color effect
            ctx.fillStyle = powerup.durationTimer % 20 < 10 ? '#ffff00' : '#ffa500'; 
            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.fillStyle;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawGoal(x, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2, GOAL_WIDTH, GOAL_HEIGHT);
        }

        function drawPlayer(player) {
            
            // 1. Draw Slide Tackle Visual
            if (player.slideTimer > 0) {
                const isSlidingRight = player.vx > 0;
                const slideWidth = player.radius * 2.5;
                const slideHeight = player.radius * 1;
                ctx.fillStyle = player.color;
                ctx.beginPath();
                // Draw a flattened capsule shape to represent sliding
                ctx.ellipse(player.x, player.y, slideWidth / 2, slideHeight / 2, 0, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add a dust/trail effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                const trailX = player.x + (isSlidingRight ? -slideWidth / 2 : slideWidth / 2);
                ctx.beginPath();
                ctx.arc(trailX, player.y, player.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                return; // Skip other draws if sliding
            }

            // 2. Draw Shield effect
            if (player.shieldTimer > 0) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#00aaff'; // Cyan blue shield
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00aaff';
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }

            // 3. Draw Player body
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color; 
            ctx.shadowBlur = player.dashTimer > 0 || player.stunTimer > 0 || player.boostTimer > 0 ? 15 : 10;
            ctx.shadowColor = player.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
            
            // 4. Draw Super Shot Meter above player
            const meterY = player.y - player.radius - 15;
            const meterWidth = 40;
            const meterHeight = 8;
            const meterX = player.x - meterWidth / 2;
            
            // Draw empty bar
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
            
            // Draw charged bar
            const charge = player.ssMeter / SS_MAX_METER;
            const chargedWidth = meterWidth * charge;
            ctx.fillStyle = charge === 1 ? '#ffcc00' : '#888800'; // Yellow if full, Gold if active
            ctx.fillRect(meterX, meterY, chargedWidth, meterHeight);
            
            // Draw bar outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);

            // 5. Draw Cooldown indicator (Dash)
            if (player.cooldownTimer > 0) {
                ctx.beginPath();
                const progress = player.cooldownTimer / DASH_COOLDOWN_FRAMES;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (2 * Math.PI * progress);
                ctx.arc(player.x, player.y, player.radius + 5, startAngle, endAngle);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // 6. Draw Cooldown indicator (Slide)
            if (player.slideCooldown > 0) {
                ctx.beginPath();
                const progress = player.slideCooldown / SLIDE_COOLDOWN_FRAMES;
                const startAngle = Math.PI / 4;
                const endAngle = startAngle + (1.5 * Math.PI * progress); // Use part of circle
                ctx.arc(player.x, player.y, player.radius + 5, startAngle, endAngle);
                ctx.strokeStyle = '#ff00ff'; // Magenta for slide
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // 7. Draw Cooldown indicator (Shield) - Existing
            if (player.shieldCooldown > 0) {
                ctx.beginPath();
                const progress = player.shieldCooldown / SHIELD_COOLDOWN_FRAMES;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (2 * Math.PI * progress);
                ctx.arc(player.x, player.y, player.radius + 5, -Math.PI / 2 - Math.PI / 4, -Math.PI / 2 + Math.PI / 4); // Draw only top left/right arc
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = ball.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#0d1a33';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            
            // Draw Lobe Shot effect
            if (ball.isLobbing) {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius * 1.5, 0, Math.PI * 2);
                ctx.strokeStyle = '#a855f7'; // Purple glow for lobe shot
                ctx.lineWidth = 3;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.closePath();
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, COURT_WIDTH, COURT_HEIGHT);

            // 1. Draw Court Markings and Zones
            drawCourt();

            // 2. Draw Goals
            drawGoal(0, '#880000'); // Left (P1 goal)
            drawGoal(COURT_WIDTH - GOAL_WIDTH, '#000088'); // Right (P2 goal)

            // 3. Draw Powerup
            drawPowerup();

            // 4. Draw Players, Possession, and Ball
            drawPossessionIndicator(player1);
            drawPossessionIndicator(player2);
            drawPlayer(player1);
            drawPlayer(player2);
            drawBall();
        }

        // --- Logic ---
        
        function updatePlayerState(player) {
            // 0. Handle Shield, Slide, Dash Timers
            if (player.shieldCooldown > 0) player.shieldCooldown--;
            if (player.shieldTimer > 0) player.shieldTimer--;
            
            if (player.slideCooldown > 0) player.slideCooldown--; // NEW
            if (player.slideTimer > 0) player.slideTimer--; // NEW

            if (player.cooldownTimer > 0) player.cooldownTimer--;
            if (player.dashTimer > 0) player.dashTimer--;
            
            // If sliding, cannot be stunned or moved normally
            if (player.slideTimer > 0) {
                 player.stunTimer = 0;
                 return;
            }

            // 1. Handle Stun Timer (MUST run first, as it overrides movement)
            if (player.stunTimer > 0) {
                player.stunTimer--;
                player.color = player.stunTimer % 4 < 2 ? '#ffffff' : player.baseColor; // Flashing stun effect
                player.speed = 0; // Stunned players cannot move
                return; // Stop any further movement or dash checks
            }
            
            // 2. Handle Boost Timer
            let currentBaseSpeed = 5; // Default speed
            if (player.boostTimer > 0) {
                player.boostTimer--;
                currentBaseSpeed = 7; // Boosted speed
                player.color = player.boostTimer % 20 < 10 ? '#00ff00' : player.baseColor; // Green flash
            } else {
                player.color = player.baseColor; // Reset if boost runs out
            }
            
            // 3. Apply Goalie Zone Speed Boost
            let inGoalieZone = false;
            if (player.isP1 && player.x < GOALIE_ZONE_DEPTH) {
                inGoalieZone = true;
            } else if (!player.isP1 && player.x > COURT_WIDTH - GOALIE_ZONE_DEPTH) {
                inGoalieZone = true;
            }
            
            if (inGoalieZone) {
                player.speed = currentBaseSpeed + GOALIE_SPEED_BONUS;
                const zoneColor = player.isP1 ? '#ffaaaa' : '#aaaaff'; 
                player.color = zoneColor; 
            } else {
                player.speed = currentBaseSpeed; 
            }

            // 4. Check for Dash Activation
            if (keysPressed[player.dashKey] && player.cooldownTimer === 0) {
                player.dashTimer = DASH_DURATION_FRAMES;
                player.cooldownTimer = DASH_COOLDOWN_FRAMES;
                playBeep(880, 0.05, 0.7); 
            }

            // Check for Slide Activation (NEW)
            if (keysPressed[player.slideKey] && player.slideCooldown === 0) {
                player.slideTimer = SLIDE_DURATION_FRAMES;
                player.slideCooldown = SLIDE_COOLDOWN_FRAMES;
                playBeep(400, 0.1, 0.8);
            }

            // Apply Dash Speed/Visuals
            if (player.dashTimer > 0) {
                player.speed = currentBaseSpeed * DASH_SPEED_MULTIPLIER;
                player.color = player.dashTimer % 4 < 2 ? player.baseColor : '#ffffff'; 
            } 
            
            // Handle Super Shot activation
            if (keysPressed[player.ssKey] && player.ssMeter >= SS_MAX_METER && !player.ssActive) {
                player.ssActive = true;
                playBeep(1500, 0.1, 1.0); 
            }
            
            // Handle Shield activation
            if (keysPressed[player.shieldKey] && player.shieldCooldown === 0) {
                player.shieldTimer = SHIELD_DURATION_FRAMES;
                player.shieldCooldown = SHIELD_COOLDOWN_FRAMES;
                playBeep(100, 0.1, 0.5); 
            }
        }

        function handleInput(player) {
            // If stunned or shielded, ignore movement
            if (player.stunTimer > 0 || player.shieldTimer > 0) {
                player.vx = 0;
                player.vy = 0;
                return;
            }

            player.vx = 0;
            player.vy = 0;
            let moved = false;
            let baseSpeed = player.speed;

            // Apply Sludge Zone Speed Multiplier
            const inSludgeZone = (player.y - player.radius < SLUDGE_ZONE_WIDTH || player.y + player.radius > COURT_HEIGHT - SLUDGE_ZONE_WIDTH);
            if (inSludgeZone && player.dashTimer === 0) {
                baseSpeed *= SLUDGE_SPEED_MULTIPLIER;
                if (player.stunTimer === 0) {
                    player.color = '#795548'; 
                }
            } else if (player.stunTimer === 0) {
                // Restore original color if not stunned and not in sludge
                player.color = player.baseColor; 
                if (player.boostTimer > 0) {
                     player.color = player.boostTimer % 20 < 10 ? '#00ff00' : player.baseColor;
                }
            }
            
            // Handle Slide Movement (NEW)
            if (player.slideTimer > 0) {
                // Check current direction (must have some direction set from previous frame/input)
                let slideDirX = player.isP1 ? 1 : -1; // Default to forward on their side
                if (keysPressed[player.keys.left]) slideDirX = -1;
                if (keysPressed[player.keys.right]) slideDirX = 1;

                player.vx = slideDirX * SLIDE_SPEED_MULTIPLIER * currentBaseSpeed;
                player.vy = 0; // Sliding is strictly horizontal for simplicity
                
                // Sliding players cannot hold the ball, force a release
                if (player.isHoldingBall) {
                    releaseBall(player, 5.0, 0.8);
                }
            } else {
                 // Normal Movement
                if (keysPressed[player.keys.up]) { player.vy = -baseSpeed; moved = true; }
                if (keysPressed[player.keys.down]) { player.vy = baseSpeed; moved = true; }
                if (keysPressed[player.keys.left]) { player.vx = -baseSpeed; moved = true; }
                if (keysPressed[player.keys.right]) { player.vx = baseSpeed; moved = true; }
            
                // Normalize diagonal movement speed
                if (moved && player.vx !== 0 && player.vy !== 0) {
                    const diagSpeed = baseSpeed / Math.sqrt(2);
                    player.vx = player.vx > 0 ? diagSpeed : -diagSpeed;
                    player.vy = player.vy > 0 ? diagSpeed : -diagSpeed;
                }
            }

            // Apply movement
            player.x += player.vx;
            player.y += player.vy;

            // Player boundary and half-court constraint
            const halfCourt = COURT_WIDTH / 2;
            const minX = player.radius;
            const maxX = COURT_WIDTH - player.radius;
            const minY = player.radius;
            const maxY = COURT_HEIGHT - player.radius;

            // Horizontal boundary (Court walls + Half-court)
            if (player.isP1) {
                player.x = Math.max(minX, Math.min(halfCourt - player.radius / 2, player.x));
            } else {
                player.x = Math.max(halfCourt + player.radius / 2, Math.min(maxX, player.x));
            }

            // Vertical boundary (Court walls)
            player.y = Math.max(minY, Math.min(maxY, player.y));
            
            // Update last player velocity for collision checks
            const playerIndex = player.isP1 ? 'p1' : 'p2';
            lastPlayerVelocity[playerIndex] = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            
            // Ball Holding Logic (NEW)
            if (player.isHoldingBall) {
                // Ball snaps to player center
                ball.x = player.x;
                ball.y = player.y;
                ball.vx = 0;
                ball.vy = 0;

                // If player is moving, release the ball gently
                if (player.slideTimer > 0 || moved || keysPressed[player.ssKey] || keysPressed[player.lobeKey]) {
                    // Super Shot or Lobe Shot will be handled in collision check on next frame, 
                    // but we must release it now.
                    
                    // Release with a slight kick in the direction of movement
                    const releaseSpeed = 5.0; 
                    const releaseVX = player.vx === 0 ? (player.isP1 ? releaseSpeed : -releaseSpeed) : player.vx;
                    const releaseVY = player.vy;

                    releaseBall(player, releaseSpeed, 0.8);
                }
            }
        }
        
        // NEW: Function to release the ball
        function releaseBall(player, initialSpeed, velocityFactor) {
            player.isHoldingBall = false;
            ball.holder = null;
            
            // Calculate release direction based on player's current velocity
            let relVX = player.vx * velocityFactor;
            let relVY = player.vy * velocityFactor;
            
            // If the player wasn't moving, give it a default shot forward
            if (relVX === 0 && relVY === 0) {
                relVX = player.isP1 ? initialSpeed : -initialSpeed;
            }
            
            // Normalize and set release speed
            const speed = Math.sqrt(relVX * relVX + relVY * relVY);
            if (speed > initialSpeed) {
                relVX = (relVX / speed) * initialSpeed;
                relVY = (relVY / speed) * initialSpeed;
            }
            
            ball.vx = relVX;
            ball.vy = relVY;
            
            lastTouchedBy = player;
        }

        // Player vs Player Collision (Stun Logic)
        function checkPlayerCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = p1.radius + p2.radius;
            const minDistanceSquared = minDistance * minDistance;

            if (distanceSquared < minDistanceSquared) {
                // Collision detected: Resolve overlap first
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;
                const normalX = dx / distance;
                const normalY = dy / distance;

                p1.x += normalX * overlap / 2;
                p1.y += normalY * overlap / 2;
                p2.x -= normalX * overlap / 2;
                p2.y -= normalY * overlap / 2;
                
                // Stun/Knockback Logic
                const p1IsDashing = p1.dashTimer > 0;
                const p2IsDashing = p2.dashTimer > 0;
                const p1IsSliding = p1.slideTimer > 0; // NEW
                const p2IsSliding = p2.slideTimer > 0; // NEW
                const p1IsShielded = p1.shieldTimer > 0; 
                const p2IsShielded = p2.shieldTimer > 0; 
                
                // Stun Hierarchy: Dash > Slide > Normal
                if (p1IsDashing && !p2IsShielded) {
                    p2.stunTimer = STUN_DURATION_FRAMES;
                    playBeep(150, 0.3, 0.9); 
                } else if (p2IsDashing && !p1IsShielded) {
                    p1.stunTimer = STUN_DURATION_FRAMES;
                    playBeep(150, 0.3, 0.9); 
                } else if (p1IsSliding && !p2IsShielded) { // NEW: Slide Tackle Stun
                    p2.stunTimer = SLIDE_STUN_DURATION;
                    playBeep(200, 0.15, 0.7);
                } else if (p2IsSliding && !p1IsShielded) { // NEW: Slide Tackle Stun
                    p1.stunTimer = SLIDE_STUN_DURATION;
                    playBeep(200, 0.15, 0.7);
                } else if (p1IsDashing && p2IsDashing) {
                    if (!p1IsShielded) p1.stunTimer = Math.floor(STUN_DURATION_FRAMES / 2);
                    if (!p2IsShielded) p2.stunTimer = Math.floor(STUN_DURATION_FRAMES / 2);
                    playBeep(500, 0.1, 0.5); 
                }
            }
        }

        // Powerup Logic (Kept from previous version)
        function spawnPowerup() {
            if (powerup.active || isPaused) return;

            if (powerup.spawnTimer > 0) {
                powerup.spawnTimer--;
                return;
            }

            // Attempt to spawn powerup after cooldown
            if (Math.random() < 0.005) { 
                // Spawn powerup in the center area, away from goal zones
                powerup.x = Math.random() * (COURT_WIDTH - 2 * GOALIE_ZONE_DEPTH) + GOALIE_ZONE_DEPTH; 
                powerup.y = Math.random() * (COURT_HEIGHT - 2 * POWERUP_RADIUS - 50) + 25;
                powerup.active = true;
                powerup.durationTimer = POWERUP_DURATION_FRAMES;
                powerup.spawnTimer = 0; 
                playBeep(1000, 0.1, 0.4); 
            }
        }
        
        function updatePowerup() {
            if (powerup.active) {
                powerup.durationTimer--;
                if (powerup.durationTimer <= 0) {
                    powerup.active = false;
                    powerup.spawnTimer = POWERUP_SPAWN_COOLDOWN; 
                    playBeep(100, 0.1, 0.3); 
                }
            } else if (powerup.spawnTimer > 0) {
                 powerup.spawnTimer--;
            }
        }

        function checkPowerupCollection(player) {
            if (!powerup.active) return;

            const dx = player.x - powerup.x;
            const dy = player.y - powerup.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = player.radius + POWERUP_RADIUS;

            if (distanceSquared < minDistance * minDistance) {
                // Collected! Grant boost and reset powerup
                player.boostTimer += POWERUP_DURATION_FRAMES;
                powerup.active = false;
                powerup.spawnTimer = POWERUP_SPAWN_COOLDOWN; 
                powerup.durationTimer = 0;
                playBeep(1200, 0.2, 0.9); 
            }
        }


        function updateBall() {
            // If ball is held, movement is handled by the player's position in handleInput
            if (ball.holder) {
                return;
            }
            
            // 1. Apply friction and move
            ball.vx *= ball.friction;
            ball.vy *= ball.friction;
            
            // Limit max speed
            let speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > ball.maxSpeed) {
                ball.vx = (ball.vx / speed) * ball.maxSpeed;
                ball.vy = (ball.vy / speed) * ball.maxSpeed;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Reset lob state after movement (for visual only)
            if (ball.isLobbing) {
                ball.isLobbing = false;
            }


            // 2. Wall Collision (Ball)
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > COURT_WIDTH) {
                ball.vx *= -1;
                ball.x = Math.max(ball.radius, Math.min(COURT_WIDTH - ball.radius, ball.x)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > COURT_HEIGHT) {
                ball.vy *= -1;
                ball.y = Math.max(ball.radius, Math.min(COURT_HEIGHT - ball.radius, ball.y)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
        }

        // Ball-Player Collision (Basic Impulse/Push)
        function checkBallPlayerCollision(player) {
            // Skip collision if the ball is already held by someone
            if (ball.holder !== null) return;
            
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = ball.radius + player.radius;
            const minDistanceSquared = minDistance * minDistance;

            if (distanceSquared < minDistanceSquared) {
                playBeep(350, 0.08, 0.6);
                
                // Update possession and charge Super Shot
                lastTouchedBy = player;
                player.ssMeter = Math.min(SS_MAX_METER, player.ssMeter + SS_CHARGE_PER_HIT);

                // Calculate the overlap
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;

                // Push the ball away to resolve collision
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Apply movement to resolve overlap
                ball.x += normalX * overlap * 1.05; 
                ball.y += normalY * overlap * 1.05;

                // Get ball's incoming speed
                const ballIncomingSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                
                // Get player's current speed
                const playerIndex = player.isP1 ? 'p1' : 'p2';
                const playerMovementSpeed = lastPlayerVelocity[playerIndex];

                // --- NEW: Ball Catching/Sticking Logic ---
                const isStationary = playerMovementSpeed < STICK_SPEED_THRESHOLD;
                if (isStationary && ballIncomingSpeed < STICK_BALL_SPEED_MAX) {
                    player.isHoldingBall = true;
                    ball.holder = player;
                    ball.vx = 0;
                    ball.vy = 0;
                    playBeep(700, 0.1, 0.8); // Catch sound
                    return; // Stop processing further shot mechanics
                }


                // --- 1. Determine Push Strength Based on Player Movement (Pre-existing logic) ---
                let pushStrength = 4.0; 

                if (player.dashTimer > 0) {
                    pushStrength *= 2.5; 
                    
                } else if (playerMovementSpeed < DEFLECTION_SPEED_THRESHOLD) {
                    // Deflection Block (Player is stationary, reflects incoming speed)
                    pushStrength = ballIncomingSpeed * DEFLECTION_MULTIPLIER;
                    player.color = '#ffcc00'; 
                    playBeep(1200, 0.1, 0.8);
                    
                } else if (playerMovementSpeed < PASS_PLAYER_SPEED_MAX) {
                    // Momentum Pass (Player is moving slowly)
                    pushStrength = PASS_MAX_OUT_SPEED;
                    
                } else {
                    // Normal Hit
                    pushStrength += (playerMovementSpeed / player.speed) * 3;
                }
                
                // --- 2. Apply Special Overrides (Shield/Super Shot/Lobe) ---
                
                // Super Shot Logic (Highest priority)
                if (player.ssActive) {
                    pushStrength = SS_SHOT_MULTIPLIER;
                    player.ssMeter = 0; 
                    player.ssActive = false; 
                    ball.isLobbing = false; 
                    playBeep(2000, 0.3, 1.0); 
                    
                } else if (player.shieldTimer > 0) {
                    // Shield Logic 
                    pushStrength = 8.0; 
                    
                } else if (keysPressed[player.lobeKey]) {
                    // Lobe Shot Logic 
                    pushStrength *= 1.2; 
                    ball.vy *= LOBE_VERTICAL_DAMPENING; 
                    ball.vx *= 0.9; 
                    ball.isLobbing = true;
                    playBeep(1800, 0.1, 0.7); 
                }


                // --- 3. Final Velocity Assignment ---
                
                // Recalculate velocity using the final push strength
                ball.vx = normalX * pushStrength;
                ball.vy = normalY * pushStrength;
            }
        }

        // Goal Check
        function checkGoal() {
            const goalTop = COURT_HEIGHT / 2 - GOAL_HEIGHT / 2;
            const goalBottom = COURT_HEIGHT / 2 + GOAL_HEIGHT / 2;
            let goalScored = false;

            // Left Goal (Player 2 scores)
            if (ball.x - ball.radius <= GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p2++;
                resetBall(player2);
                goalScored = true;
            }

            // Right Goal (Player 1 scores)
            if (ball.x + ball.radius >= COURT_WIDTH - GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p1++;
                resetBall(player1);
                goalScored = true;
            }

            if (goalScored) {
                updateScoreboard();
                shakeDuration = SHAKE_DURATION_FRAMES; // Activate screen shake
                playBeep(600, 0.5, 0.8); 
                lastTouchedBy = null; 
            }
            return goalScored;
        }


        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (!isGameRunning) return;

            // Screen Shake Logic
            let offsetX = 0;
            let offsetY = 0;
            if (shakeDuration > 0) {
                offsetX = (Math.random() - 0.5) * SHAKE_INTENSITY * (shakeDuration / SHAKE_DURATION_FRAMES);
                offsetY = (Math.random() - 0.5) * SHAKE_INTENSITY * (shakeDuration / SHAKE_DURATION_FRAMES);
                shakeDuration--;
            }
            
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY); // Apply transformation for shake

            // Only update game state if not paused
            if (!isPaused) {
                // 1. Update Player States 
                updatePlayerState(player1);
                updatePlayerState(player2);

                // 2. Handle Input & Player Movement
                handleInput(player1);
                handleInput(player2);

                // 3. Powerup Management
                spawnPowerup();
                updatePowerup();

                // 4. Update Ball Position and Physics
                updateBall();

                // 5. Collision Checks
                checkBallPlayerCollision(player1);
                checkBallPlayerCollision(player2);
                checkPlayerCollision(player1, player2); 
                checkPowerupCollection(player1); 
                checkPowerupCollection(player2);

                // 6. Goal Check
                checkGoal();
            }

            // 7. Draw Everything
            drawGame();

            // Reset transformation matrix after drawing (crucial for normal rendering next frame)
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            lastTime = currentTime;

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game on window load
        window.onload = function() {
            // Set up the canvas size (using logical size 800x500 for internal math)
            canvas.width = COURT_WIDTH; 
            canvas.height = COURT_HEIGHT; 
            
            updateScoreboard();
            setupGame();
        };

    </script>
</body>
</html>
