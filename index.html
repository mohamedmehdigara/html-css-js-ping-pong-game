<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Pong</title>
    <!-- Load Tone.js for simple sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* General Setup */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d0d0d;
            color: #c0f0c0; /* Neon green text */
            font-family: 'Inter', sans-serif;
            user-select: none;
            overflow: hidden;
            padding: 20px;
        }

        /* Game Container */
        .game-container {
            border: 2px solid #00ff00; /* Neon border */
            box-shadow: 0 0 15px #00ff00, inset 0 0 10px #00ff00;
            border-radius: 10px;
            padding: 10px;
            background-color: #000000;
            max-width: 90vw;
            width: 820px; /* Canvas width + padding */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Controls Area */
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            align-items: center;
            font-size: 1rem;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        
        /* Control Elements Styling */
        .control-button, .control-select {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 5px #00ff00;
            font-weight: bold;
        }

        .control-button:hover, .control-select:hover {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 10px #00ff00;
        }

        /* Scoreboard */
        #scoreboard {
            font-size: 3rem;
            font-weight: bold;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-shadow: 0 0 8px #00ff00;
            color: #00ff00;
        }

        /* Canvas (Game Area) */
        #gameCanvas {
            background-color: #000000;
            display: block;
            border-radius: 5px;
        }

        /* Message Box (For Start/End Game/Pause) */
        #messageBox {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); /* Slightly darker overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }

        .message-content {
            background: #111;
            border: 2px solid #ff00ff; /* Neon magenta border */
            box-shadow: 0 0 20px #ff00ff;
            padding: 30px 40px;
            border-radius: 10px;
        }

        .message-content h2 {
            font-size: 2.5rem;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            margin-top: 0;
        }

        .message-content p {
            font-size: 1.2rem;
            color: #c0f0c0;
            margin-bottom: 20px;
        }

        #startButton {
            background: #00ff00;
            color: #000000;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #00aa00;
        }

        #startButton:hover {
            background: #00dd00;
            box-shadow: 0 2px 0 #00aa00;
            transform: translateY(2px);
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #scoreboard {
                font-size: 2rem;
            }
            .message-content h2 {
                font-size: 1.8rem;
            }
            .message-content p {
                font-size: 1rem;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
        }

    </style>
</head>
<body>

    <div class="game-container">
        <div id="scoreboard">0 - 0</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- New Controls -->
        <div class="controls">
            <button id="pauseButton" class="control-button" disabled>Pause (P)</button>
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty" class="control-select">
                <option value="4">Easy</option>
                <option value="6" selected>Medium</option>
                <option value="8">Hard</option>
                <option value="10">Insane</option>
            </select>
        </div>
    </div>

    <!-- Message Overlay -->
    <div id="messageBox">
        <div class="message-content">
            <h2 id="messageHeader">Welcome to Arcade Pong!</h2>
            <p id="messageBody">
                Use your **mouse or touch** to move the left paddle (Player 1). <br>
                First to 5 points wins! Select difficulty below.
            </p>
            <button id="startButton">Start Game</button>
        </div>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 100;
        const BALL_SIZE = 10;
        const MAX_SCORE = 5;

        // Dynamic Game State Variables
        let AI_SPEED_CURRENT = 6;
        let INITIAL_BALL_SPEED_CURRENT = 7;

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreboard = document.getElementById('scoreboard');
        const messageBox = document.getElementById('messageBox');
        const messageHeader = document.getElementById('messageHeader');
        const messageBody = document.getElementById('messageBody');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const difficultySelect = document.getElementById('difficulty');

        let animationFrameId = null;
        let isGameRunning = false; // True when game is active (not Game Over)
        let isPaused = true;       // True when game is paused (message box visible)
        let playerY = (CANVAS_HEIGHT - PADDLE_HEIGHT) / 2;
        let aiY = (CANVAS_HEIGHT - PADDLE_HEIGHT) / 2;
        let scorePlayer = 0;
        let scoreAI = 0;

        // Ball State
        let ballX, ballY, ballSpeedX, ballSpeedY, ballSpeedMagnitude;

        // Sound Effects (Tone.js)
        let paddleSynth, scoreSynth, wallSynth;

        /**
         * Initializes the audio context and sound synths using Tone.js.
         */
        function initAudio() {
            // Synth for paddle hits (short, high-pitched)
            paddleSynth = new Tone.PluckSynth().toDestination();

            // Synth for wall bounces (low, metallic noise)
            wallSynth = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();

            // Synth for scoring (simple melodic tone)
            scoreSynth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0, release: 0.3 }
            }).toDestination();
        }
        
        // --- Utility Functions ---

        /**
         * Resets the ball to the center with a random initial direction.
         * @param {number} direction - 1 for serving towards AI, -1 for serving towards player.
         */
        function resetBall(direction) {
            ballX = CANVAS_WIDTH / 2;
            ballY = CANVAS_HEIGHT / 2;
            ballSpeedMagnitude = INITIAL_BALL_SPEED_CURRENT;

            // Generate a random angle, avoiding flat angles (-45deg to +45deg or 135deg to 225deg)
            let angle = Math.random() * (Math.PI / 2) - (Math.PI / 4); 

            // Determine X direction based on who just scored
            if (direction === -1) { // Serve towards Player (left)
                angle += Math.PI;
            }

            ballSpeedX = Math.cos(angle) * ballSpeedMagnitude;
            ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
        }

        // --- Drawing Functions ---

        /**
         * Clears the canvas with semi-transparent fill to create a ghosting ball trail effect.
         */
        function drawBackground() {
            // Use semi-transparent black fill (alpha 0.2) to create a subtle ghosting trail
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Redraw the center net fully opaque
            ctx.strokeStyle = '#006600'; 
            ctx.lineWidth = 4;
            ctx.setLineDash([15, 10]); 
            ctx.globalAlpha = 1.0; 
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH / 2, 0);
            ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
            ctx.stroke();
            ctx.setLineDash([]); 
        }

        /**
         * Draws a paddle.
         */
        function drawPaddle(x, y) {
            ctx.globalAlpha = 1.0; // Ensure solid color
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 10;
            ctx.fillRect(x, y, PADDLE_WIDTH, PADDLE_HEIGHT);
            ctx.shadowBlur = 0;
        }

        /**
         * Draws the ball.
         */
        function drawBall() {
            ctx.globalAlpha = 1.0; // Ensure solid color
            ctx.fillStyle = '#00ff00'; 
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(ballX, ballY, BALL_SIZE / 2, 0, Math.PI * 2, true);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // --- Game Logic ---

        /**
         * Updates the AI paddle position to track the ball using dynamic speed.
         */
        function moveAI() {
            const aiCenter = aiY + PADDLE_HEIGHT / 2;
            const diff = ballY - aiCenter;

            // Simple movement: move towards the ball's Y center using AI_SPEED_CURRENT
            if (diff > 0) {
                aiY = Math.min(aiY + AI_SPEED_CURRENT, CANVAS_HEIGHT - PADDLE_HEIGHT);
            } else if (diff < 0) {
                aiY = Math.max(aiY - AI_SPEED_CURRENT, 0);
            }
        }

        /**
         * Handles collisions, scoring, and plays sound effects.
         */
        function update() {
            // 1. Move Ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // 2. Move AI
            moveAI();

            // 3. Wall Collision (Top/Bottom) - PLAYS WALL SOUND
            if (ballY - BALL_SIZE / 2 < 0 || ballY + BALL_SIZE / 2 > CANVAS_HEIGHT) {
                ballSpeedY = -ballSpeedY; 
                if (wallSynth) wallSynth.triggerAttackRelease('C2', '8n');
            }

            // 4. Player Paddle Collision (Left side) - PLAYS PADDLE SOUND
            if (ballSpeedX < 0) { 
                if (
                    ballX - BALL_SIZE / 2 < PADDLE_WIDTH && 
                    ballY > playerY && 
                    ballY < playerY + PADDLE_HEIGHT 
                ) {
                    // Reverse X direction and calculate reflection angle
                    const hitPoint = (ballY - (playerY + PADDLE_HEIGHT / 2)) / (PADDLE_HEIGHT / 2);
                    const angle = hitPoint * (Math.PI / 4);
                    
                    // Increase speed slightly, capped at 20
                    ballSpeedMagnitude = Math.min(ballSpeedMagnitude + 0.5, 20); 
                    
                    ballSpeedX = Math.cos(angle) * ballSpeedMagnitude;
                    ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
                    
                    if (paddleSynth) paddleSynth.triggerAttackRelease('C5', '16n');
                }
            }

            // 5. AI Paddle Collision (Right side) - PLAYS PADDLE SOUND
            if (ballSpeedX > 0) { 
                if (
                    ballX + BALL_SIZE / 2 > CANVAS_WIDTH - PADDLE_WIDTH && 
                    ballY > aiY && 
                    ballY < aiY + PADDLE_HEIGHT 
                ) {
                    // Reverse X direction and calculate reflection angle
                    const hitPoint = (ballY - (aiY + PADDLE_HEIGHT / 2)) / (PADDLE_HEIGHT / 2);
                    const angle = hitPoint * (Math.PI / 4);
                    
                    // Increase speed slightly, capped at 20
                    ballSpeedMagnitude = Math.min(ballSpeedMagnitude + 0.5, 20); 

                    // Use the reflected angle and magnitude
                    ballSpeedX = -Math.cos(angle) * ballSpeedMagnitude; 
                    ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
                    
                    if (paddleSynth) paddleSynth.triggerAttackRelease('G5', '16n');
                }
            }

            // 6. Scoring (Left Wall: AI scores) - PLAYS SCORE SOUND
            if (ballX < 0) {
                scoreAI++;
                scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
                if (scoreSynth) {
                    scoreSynth.triggerAttackRelease('C4', '4n', Tone.now(), 0.5); 
                    scoreSynth.triggerAttackRelease('G4', '4n', Tone.now() + 0.2, 0.5);
                }
                
                if (scoreAI >= MAX_SCORE) {
                    endGame("AI Wins!");
                } else {
                    resetBall(1); // Serve towards AI
                }
            }

            // 7. Scoring (Right Wall: Player scores) - PLAYS SCORE SOUND
            if (ballX > CANVAS_WIDTH) {
                scorePlayer++;
                scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
                if (scoreSynth) {
                    scoreSynth.triggerAttackRelease('C5', '4n', Tone.now(), 0.5); 
                    scoreSynth.triggerAttackRelease('G5', '4n', Tone.now() + 0.2, 0.5);
                }
                
                if (scorePlayer >= MAX_SCORE) {
                    endGame("Player Wins!");
                } else {
                    resetBall(-1); // Serve towards Player
                }
            }
        }

        // --- Game Loop and Control ---

        /**
         * The main game loop function.
         */
        function gameLoop() {
            if (!isGameRunning || isPaused) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // 1. Logic Update
            update();

            // 2. Drawing
            drawBackground();
            drawPaddle(0, playerY);
            drawPaddle(CANVAS_WIDTH - PADDLE_WIDTH, aiY);
            drawBall();

            // 3. Next Frame
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Initializes the game state and starts the loop.
         */
        function startGame() {
            scorePlayer = 0;
            scoreAI = 0;
            scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
            messageBox.style.display = 'none';
            
            // Set speed based on selected difficulty
            AI_SPEED_CURRENT = parseInt(difficultySelect.value);
            // Ball speed scales slightly with AI speed
            INITIAL_BALL_SPEED_CURRENT = 7 + (AI_SPEED_CURRENT - 6) * 0.5;

            // Initialize audio context on first user interaction
            if (!paddleSynth) {
                Tone.start().then(initAudio);
            }
            
            resetBall(Math.random() < 0.5 ? -1 : 1);
            
            isPaused = false;
            isGameRunning = true;
            pauseButton.disabled = false;
            pauseButton.textContent = "Pause (P)";
            gameLoop();
        }
        
        /**
         * Toggles the game pause state.
         */
        function togglePause() {
            if (!isGameRunning) return; 

            if (isPaused) {
                // Resume
                isPaused = false;
                pauseButton.textContent = "Pause (P)";
                messageBox.style.display = 'none';
                gameLoop(); // Restart the animation loop
            } else {
                // Pause
                isPaused = true;
                pauseButton.textContent = "Resume (P)";
                cancelAnimationFrame(animationFrameId);
                
                messageHeader.textContent = "Game Paused";
                messageBody.textContent = "Press 'P' or click 'Resume' to continue.";
                startButton.textContent = 'Resume Game';
                messageBox.style.display = 'flex';
            }
        }

        /**
         * Ends the game and displays the winner.
         */
        function endGame(winnerMessage) {
            isGameRunning = false;
            isPaused = true;
            cancelAnimationFrame(animationFrameId);
            pauseButton.disabled = true;

            messageHeader.textContent = winnerMessage;
            messageBody.textContent = `Final Score: ${scorePlayer} - ${scoreAI}. Click below to play again.`;
            startButton.textContent = 'Play Again';
            messageBox.style.display = 'flex';
        }


        // --- Event Listeners ---

        /**
         * Moves the player paddle based on mouse/touch Y position.
         */
        function handleInput(event) {
            if (!isGameRunning || isPaused) return;

            let clientY;
            if (event.touches) {
                // For touch events
                clientY = event.touches[0].clientY;
            } else {
                // For mouse events
                clientY = event.clientY;
            }

            // Get the bounding box of the canvas to calculate relative position
            const rect = canvas.getBoundingClientRect();
            
            // Calculate relative Y position within the canvas (0 to CANVAS_HEIGHT)
            let relativeY = clientY - rect.top;

            // Calculate the new Y position for the paddle center
            let newCenterY = relativeY;

            // Constrain the paddle position to stay within the canvas bounds
            let newPaddleY = newCenterY - PADDLE_HEIGHT / 2;

            // Apply constraints
            playerY = Math.max(0, Math.min(newPaddleY, CANVAS_HEIGHT - PADDLE_HEIGHT));
        }

        // Input listeners
        canvas.addEventListener('mousemove', handleInput);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            handleInput(e);
        }, { passive: false });
        
        // Button listeners
        startButton.addEventListener('click', () => {
             // If starting from a paused state, we need to handle it like a resume
             if (isPaused && isGameRunning) {
                 togglePause();
             } else {
                 startGame();
             }
        });
        
        pauseButton.addEventListener('click', togglePause);
        
        // Keyboard listener for pause/resume
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        // Initial draw when the page loads
        window.onload = () => {
             // Set the initial canvas size on load
             canvas.width = CANVAS_WIDTH;
             canvas.height = CANVAS_HEIGHT;
             drawBackground();
             drawPaddle(0, playerY);
             drawPaddle(CANVAS_WIDTH - PADDLE_WIDTH, aiY);
        }
    </script>

</body>
</html>
