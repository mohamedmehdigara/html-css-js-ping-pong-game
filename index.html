<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Pong</title>
    <!-- Load Tone.js for simple sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* General Setup */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d0d0d;
            color: #c0f0c0; /* Neon green text */
            font-family: 'Inter', sans-serif;
            user-select: none;
            overflow: hidden;
            padding: 20px;
        }

        /* Game Container */
        .game-container {
            border: 2px solid #00ff00; /* Neon border */
            box-shadow: 0 0 15px #00ff00, inset 0 0 10px #00ff00;
            border-radius: 10px;
            padding: 10px;
            background-color: #000000;
            max-width: 90vw;
            width: 820px; /* Canvas width + padding */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Controls Area */
        .controls {
            display: flex;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
            gap: 20px;
            margin-top: 15px;
            align-items: center;
            font-size: 1rem;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            justify-content: center;
        }
        
        /* Control Elements Styling */
        .control-button, .control-select {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 5px #00ff00;
            font-weight: bold;
        }

        .control-button:hover, .control-select:hover {
            background: #00ff00;
            color: #000000;
            box-shadow: 0 0 10px #00ff00;
        }

        /* Scoreboard */
        #scoreboard {
            font-size: 3rem;
            font-weight: bold;
            letter-spacing: 5px;
            margin-bottom: 10px;
            text-shadow: 0 0 8px #00ff00;
            color: #00ff00;
        }

        /* Canvas (Game Area) */
        #gameCanvas {
            background-color: #000000;
            display: block;
            border-radius: 5px;
        }

        /* Message Box (For Start/End Game/Pause) */
        #messageBox {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85); 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }

        .message-content {
            background: #111;
            border: 2px solid #ff00ff; 
            box-shadow: 0 0 20px #ff00ff;
            padding: 30px 40px;
            border-radius: 10px;
        }

        .message-content h2 {
            font-size: 2.5rem;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            margin-top: 0;
        }

        .message-content p {
            font-size: 1.2rem;
            color: #c0f0c0;
            margin-bottom: 20px;
        }

        #startButton {
            background: #00ff00;
            color: #000000;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #00aa00;
        }

        #startButton:hover {
            background: #00dd00;
            box-shadow: 0 2px 0 #00aa00;
            transform: translateY(2px);
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #scoreboard {
                font-size: 2rem;
            }
            .message-content h2 {
                font-size: 1.8rem;
            }
            .message-content p {
                font-size: 1rem;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
        }

    </style>
</head>
<body>

    <div class="game-container">
        <div id="scoreboard">0 - 0</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- Controls -->
        <div class="controls">
            <button id="pauseButton" class="control-button" disabled>Pause (P)</button>
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty" class="control-select">
                <option value="4">Easy</option>
                <option value="6" selected>Medium</option>
                <option value="8">Hard</option>
                <option value="10">Insane</option>
            </select>
            <!-- MAX SCORE SELECTOR -->
            <label for="maxScore">Score To Win:</label>
            <select id="maxScore" class="control-select">
                <option value="5" selected>5</option>
                <option value="7">7</option>
                <option value="10">10</option>
            </select>
        </div>
    </div>

    <!-- Message Overlay -->
    <div id="messageBox">
        <div class="message-content">
            <h2 id="messageHeader">Welcome to Arcade Pong!</h2>
            <p id="messageBody">
                Use your **mouse or touch** to move the left paddle (Player 1). <br>
                Select your difficulty and score limit below.
            </p>
            <button id="startButton">Start Game</button>
        </div>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 100; // Default paddle height
        const BALL_SIZE = 10;
        
        // Power-up Constants
        const POWERUP_SIZE = 20;
        const POWERUP_DURATION_MS = 5000;
        const POWERUP_CHANCE = 0.15; // 15% chance to spawn on score reset

        // Dynamic Game State Variables
        let AI_SPEED_CURRENT = 6;
        let INITIAL_BALL_SPEED_CURRENT = 7;
        let MAX_SCORE_CURRENT = 5; 
        
        let isAudioReady = false; // New flag to track audio initialization status

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreboard = document.getElementById('scoreboard');
        const messageBox = document.getElementById('messageBox');
        const messageHeader = document.getElementById('messageHeader');
        const messageBody = document.getElementById('messageBody');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const difficultySelect = document.getElementById('difficulty');
        const maxScoreSelect = document.getElementById('maxScore');

        let animationFrameId = null;
        let isGameRunning = false; 
        let isPaused = true;       
        let playerY = (CANVAS_HEIGHT - PADDLE_HEIGHT) / 2;
        let aiY = (CANVAS_HEIGHT - PADDLE_HEIGHT) / 2;
        let scorePlayer = 0;
        let scoreAI = 0;
        let playerPaddleHeight = PADDLE_HEIGHT; // Dynamic height for player paddle

        // Ball State
        let ballX, ballY, ballSpeedX, ballSpeedY, ballSpeedMagnitude;

        // Power-up State
        let powerUpX = -50; // Off screen initially
        let powerUpY = -50;
        let isPowerUpActive = false;
        let powerUpTimer = null;
        
        // Sound Effects (Tone.js)
        let paddleSynth, scoreSynth, wallSynth;

        /**
         * Initializes the audio context and sound synths using Tone.js.
         */
        function initAudio() {
            // Synth for paddle hits (short, high-pitched)
            paddleSynth = new Tone.PluckSynth().toDestination();

            // Synth for wall bounces (low, metallic noise)
            wallSynth = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();

            // Synth for scoring (simple melodic tone)
            scoreSynth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0, release: 0.3 }
            }).toDestination();

            isAudioReady = true; // Mark audio as initialized
        }
        
        // --- Utility Functions ---

        /**
         * Resets the ball to the center with a random initial direction.
         * @param {number} direction - 1 for serving towards AI, -1 for serving towards player.
         */
        function resetBall(direction) {
            ballX = CANVAS_WIDTH / 2;
            ballY = CANVAS_HEIGHT / 2;
            ballSpeedMagnitude = INITIAL_BALL_SPEED_CURRENT;

            let angle = Math.random() * (Math.PI / 2) - (Math.PI / 4); 

            if (direction === -1) { 
                angle += Math.PI;
            }

            ballSpeedX = Math.cos(angle) * ballSpeedMagnitude;
            ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
            
            // Try to spawn power-up after a score
            spawnPowerUp();
        }
        
        /**
         * Randomly spawns a power-up in the center third of the screen.
         */
        function spawnPowerUp() {
            if (isPowerUpActive) return;

            // 15% chance to spawn on score reset
            if (Math.random() < POWERUP_CHANCE) {
                // Spawn in the middle 50% of the screen
                const minX = CANVAS_WIDTH * 0.25;
                const maxX = CANVAS_WIDTH * 0.75 - POWERUP_SIZE;

                powerUpX = minX + Math.random() * (maxX - minX);
                powerUpY = Math.random() * (CANVAS_HEIGHT - POWERUP_SIZE);
                isPowerUpActive = true;

                // Power-up disappears after 8 seconds if not collected
                clearTimeout(powerUpTimer);
                powerUpTimer = setTimeout(() => {
                    if (isPowerUpActive) {
                        isPowerUpActive = false;
                        powerUpX = -50; 
                        powerUpY = -50;
                    }
                }, 8000); 
            }
        }


        // --- Drawing Functions ---

        /**
         * Clears the canvas with semi-transparent fill to create a ghosting ball trail effect.
         */
        function drawBackground() {
            // Use semi-transparent black fill (alpha 0.2) to create a subtle ghosting trail
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Redraw the center net fully opaque
            ctx.strokeStyle = '#006600'; 
            ctx.lineWidth = 4;
            ctx.setLineDash([15, 10]); 
            ctx.globalAlpha = 1.0; 
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH / 2, 0);
            ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
            ctx.stroke();
            ctx.setLineDash([]); 
        }

        /**
         * Draws a paddle.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} height - The current height of the paddle.
         */
        function drawPaddle(x, y, height) {
            ctx.globalAlpha = 1.0; 
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 10;
            ctx.fillRect(x, y, PADDLE_WIDTH, height);
            ctx.shadowBlur = 0;
        }

        /**
         * Draws the ball.
         */
        function drawBall() {
            ctx.globalAlpha = 1.0; 
            ctx.fillStyle = '#00ff00'; 
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(ballX, ballY, BALL_SIZE / 2, 0, Math.PI * 2, true);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        /**
         * Draws the power-up item.
         */
        function drawPowerUp() {
            if (isPowerUpActive) {
                ctx.fillStyle = '#ffff00'; // Yellow/Gold color
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
                // Draw a simple square for the power-up
                ctx.fillRect(powerUpX, powerUpY, POWERUP_SIZE, POWERUP_SIZE); 
                
                // Draw a '+' sign for clarity
                ctx.fillStyle = '#000000';
                ctx.fillRect(powerUpX + 5, powerUpY + 9, 10, 2);
                ctx.fillRect(powerUpX + 9, powerUpY + 5, 2, 10);

                ctx.shadowBlur = 0;
            }
        }


        // --- Game Logic ---

        /**
         * Updates the AI paddle position to track the ball using dynamic speed.
         */
        function moveAI() {
            // AI always uses the default paddle height
            const aiCenter = aiY + PADDLE_HEIGHT / 2; 
            const diff = ballY - aiCenter;

            if (diff > 0) {
                aiY = Math.min(aiY + AI_SPEED_CURRENT, CANVAS_HEIGHT - PADDLE_HEIGHT);
            } else if (diff < 0) {
                aiY = Math.max(aiY - AI_SPEED_CURRENT, 0);
            }
        }

        /**
         * Handles collisions, scoring, and plays sound effects.
         */
        function update() {
            // 1. Move Ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // 2. Move AI
            moveAI();
            
            // 3. Power-up Collision Check (Player only) - CORRECTION: Using robust AABB collision
            if (isPowerUpActive) {
                const ballRadius = BALL_SIZE / 2;

                // Check for collision between the ball (circle) and the power-up (square)
                if (
                    ballX + ballRadius > powerUpX && // Ball right edge past power-up left edge
                    ballX - ballRadius < powerUpX + POWERUP_SIZE && // Ball left edge before power-up right edge
                    ballY + ballRadius > powerUpY && // Ball bottom edge past power-up top edge
                    ballY - ballRadius < powerUpY + POWERUP_SIZE // Ball top edge before power-up bottom edge
                ) {
                    // Check if ball is moving towards the player paddle's side (left)
                    // This ensures the power-up is collected as a benefit to the player
                    if (ballSpeedX < 0) { 
                        // Power-up collected!
                        isPowerUpActive = false;
                        powerUpX = -50; 
                        powerUpY = -50;
                        
                        // Increase paddle size temporarily
                        playerPaddleHeight = PADDLE_HEIGHT * 2;
                        
                        // Play a positive sound
                        if (scoreSynth) scoreSynth.triggerAttackRelease('E6', '8n');
                        
                        // Set timer to revert size after POWERUP_DURATION_MS
                        clearTimeout(powerUpTimer);
                        powerUpTimer = setTimeout(() => {
                            playerPaddleHeight = PADDLE_HEIGHT;
                            if (scoreSynth) scoreSynth.triggerAttackRelease('D3', '8n'); // Revert sound
                        }, POWERUP_DURATION_MS); 
                    }
                }
            }


            // 4. Wall Collision (Top/Bottom) - PLAYS WALL SOUND
            if (ballY - BALL_SIZE / 2 < 0 || ballY + BALL_SIZE / 2 > CANVAS_HEIGHT) {
                ballSpeedY = -ballSpeedY; 
                if (wallSynth) wallSynth.triggerAttackRelease('C2', '8n');
            }

            // 5. Player Paddle Collision (Left side) - PLAYS PADDLE SOUND
            if (ballSpeedX < 0) { 
                if (
                    ballX - BALL_SIZE / 2 < PADDLE_WIDTH && 
                    ballY > playerY && 
                    ballY < playerY + playerPaddleHeight // Use dynamic height
                ) {
                    // Reverse X direction and calculate reflection angle
                    const hitPoint = (ballY - (playerY + playerPaddleHeight / 2)) / (playerPaddleHeight / 2);
                    const angle = hitPoint * (Math.PI / 4);
                    
                    ballSpeedMagnitude = Math.min(ballSpeedMagnitude + 0.5, 20); 
                    
                    ballSpeedX = Math.cos(angle) * ballSpeedMagnitude;
                    ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
                    
                    if (paddleSynth) paddleSynth.triggerAttackRelease('C5', '16n');
                }
            }

            // 6. AI Paddle Collision (Right side) - PLAYS PADDLE SOUND
            if (ballSpeedX > 0) { 
                if (
                    ballX + BALL_SIZE / 2 > CANVAS_WIDTH - PADDLE_WIDTH && 
                    ballY > aiY && 
                    ballY < aiY + PADDLE_HEIGHT // AI uses default height
                ) {
                    // Reverse X direction and calculate reflection angle
                    const hitPoint = (ballY - (aiY + PADDLE_HEIGHT / 2)) / (PADDLE_HEIGHT / 2);
                    const angle = hitPoint * (Math.PI / 4);
                    
                    ballSpeedMagnitude = Math.min(ballSpeedMagnitude + 0.5, 20); 

                    ballSpeedX = -Math.cos(angle) * ballSpeedMagnitude; 
                    ballSpeedY = Math.sin(angle) * ballSpeedMagnitude;
                    
                    if (paddleSynth) paddleSynth.triggerAttackRelease('G5', '16n');
                }
            }

            // 7. Scoring (Left Wall: AI scores) - PLAYS SCORE SOUND
            if (ballX < 0) {
                scoreAI++;
                scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
                if (scoreSynth) {
                    scoreSynth.triggerAttackRelease('C4', '4n', Tone.now(), 0.5); 
                    scoreSynth.triggerAttackRelease('G4', '4n', Tone.now() + 0.2, 0.5);
                }
                
                if (scoreAI >= MAX_SCORE_CURRENT) {
                    endGame("AI Wins!");
                } else {
                    resetBall(1); // Serve towards AI
                }
            }

            // 8. Scoring (Right Wall: Player scores) - PLAYS SCORE SOUND
            if (ballX > CANVAS_WIDTH) {
                scorePlayer++;
                scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
                if (scoreSynth) {
                    scoreSynth.triggerAttackRelease('C5', '4n', Tone.now(), 0.5); 
                    scoreSynth.triggerAttackRelease('G5', '4n', Tone.now() + 0.2, 0.5);
                }
                
                if (scorePlayer >= MAX_SCORE_CURRENT) {
                    endGame("Player Wins!");
                } else {
                    resetBall(-1); // Serve towards Player
                }
            }
        }

        // --- Game Loop and Control ---

        /**
         * The main game loop function.
         */
        function gameLoop() {
            if (!isGameRunning || isPaused) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            // 1. Logic Update
            update();

            // 2. Drawing
            drawBackground();
            drawPaddle(0, playerY, playerPaddleHeight); // Draw player with dynamic height
            drawPaddle(CANVAS_WIDTH - PADDLE_WIDTH, aiY, PADDLE_HEIGHT); // Draw AI with static height
            drawBall();
            drawPowerUp(); // Draw power-up if active

            // 3. Next Frame
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        /**
         * Contains the actual logic to start the game loop once setup is complete.
         */
        function startInternalGameLogic() {
            resetBall(Math.random() < 0.5 ? -1 : 1);
            
            isPaused = false;
            isGameRunning = true;
            pauseButton.disabled = false;
            pauseButton.textContent = "Pause (P)";
            gameLoop();
        }

        /**
         * Initializes the game state and starts the loop.
         */
        function startGame() {
            scorePlayer = 0;
            scoreAI = 0;
            
            // Reset player paddle height and clear power-up state
            playerPaddleHeight = PADDLE_HEIGHT;
            isPowerUpActive = false;
            powerUpX = -50;
            clearTimeout(powerUpTimer);

            // Set dynamic game configuration based on selectors
            MAX_SCORE_CURRENT = parseInt(maxScoreSelect.value);
            AI_SPEED_CURRENT = parseInt(difficultySelect.value);
            INITIAL_BALL_SPEED_CURRENT = 7 + (AI_SPEED_CURRENT - 6) * 0.5;

            scoreboard.textContent = `${scorePlayer} - ${scoreAI}`;
            messageBox.style.display = 'none';
            
            // Check if audio is initialized. If not, initialize it and then start the game.
            if (!isAudioReady) {
                // Ensure audio context is resumed/started on user interaction
                Tone.start().then(() => {
                    initAudio(); // initializes synths and sets isAudioReady = true
                    // Now that audio is ready, start the game logic
                    startInternalGameLogic();
                }).catch(e => {
                    console.error("Audio context failed to start:", e);
                    // Start game logic even if audio fails
                    startInternalGameLogic();
                });
            } else {
                startInternalGameLogic();
            }
        }
        
        /**
         * Toggles the game pause state.
         */
        function togglePause() {
            if (!isGameRunning) return; 

            if (isPaused) {
                // Resume
                isPaused = false;
                pauseButton.textContent = "Pause (P)";
                messageBox.style.display = 'none';
                gameLoop(); // Restart the animation loop
            } else {
                // Pause
                isPaused = true;
                pauseButton.textContent = "Resume (P)";
                cancelAnimationFrame(animationFrameId);
                
                messageHeader.textContent = "Game Paused";
                messageBody.textContent = "Press 'P' or click 'Resume' to continue.";
                startButton.textContent = 'Resume Game';
                messageBox.style.display = 'flex';
            }
        }

        /**
         * Ends the game and displays the winner.
         */
        function endGame(winnerMessage) {
            isGameRunning = false;
            isPaused = true;
            cancelAnimationFrame(animationFrameId);
            pauseButton.disabled = true;

            // Stop the power-up timer if running
            clearTimeout(powerUpTimer);
            
            messageHeader.textContent = winnerMessage;
            messageBody.textContent = `Final Score: ${scorePlayer} - ${scoreAI}. Click below to play again.`;
            startButton.textContent = 'Play Again';
            messageBox.style.display = 'flex';
        }


        // --- Event Listeners ---

        /**
         * Moves the player paddle based on mouse/touch Y position.
         */
        function handleInput(event) {
            if (!isGameRunning || isPaused) return;

            let clientY;
            if (event.touches) {
                clientY = event.touches[0].clientY;
            } else {
                clientY = event.clientY;
            }

            const rect = canvas.getBoundingClientRect();
            let relativeY = clientY - rect.top;
            
            // Calculate new Y position for the paddle center
            let newCenterY = relativeY;

            // Constrain the paddle position using the dynamic playerPaddleHeight
            let newPaddleY = newCenterY - playerPaddleHeight / 2;

            // Apply constraints, ensuring the top of the paddle is never negative 
            // and the bottom of the paddle is never past the canvas bottom.
            playerY = Math.max(0, Math.min(newPaddleY, CANVAS_HEIGHT - playerPaddleHeight));
        }

        // Input listeners
        canvas.addEventListener('mousemove', handleInput);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            handleInput(e);
        }, { passive: false });
        
        // Button listeners
        startButton.addEventListener('click', () => {
             // If starting from a paused state, resume
             if (isPaused && isGameRunning) {
                 togglePause();
             } else {
                 startGame();
             }
        });
        
        pauseButton.addEventListener('click', togglePause);
        
        // Keyboard listener for pause/resume
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        // Initial draw when the page loads
        window.onload = () => {
             // Set the initial canvas size on load
             canvas.width = CANVAS_WIDTH;
             canvas.height = CANVAS_HEIGHT;
             drawBackground();
             drawPaddle(0, playerY, playerPaddleHeight);
             drawPaddle(CANVAS_WIDTH - PADDLE_WIDTH, aiY, PADDLE_HEIGHT);
        }
    </script>

</body>
</html>
