<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handball Court Game</title>
    <style>
        /*
        Global Styling
        */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1e3a8a, #0c4a6e); /* Deep Blue Gradient */
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            background-color: #0d1a33; /* Dark background for score/info */
            position: relative; /* Needed for absolute positioning of overlay */
        }

        /*
        Canvas Styling
        */
        canvas {
            display: block;
            border: 4px solid #ffffff;
            border-radius: 10px;
            background-color: #22c55e; /* Vibrant Green Court */
            touch-action: none; /* Disable default touch actions */
            max-width: 95vw;
            max-height: 80vh;
        }

        /*
        Scoreboard and Info Styling
        */
        .scoreboard {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 800px;
            margin-bottom: 15px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .player-info {
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 150px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
        }

        #score-p1 { background-color: #ef4444; } /* Red */
        #score-p2 { background-color: #3b82f6; } /* Blue */
        
        .controls-info {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .controls-info strong {
            color: #fcd34d;
        }
        
        /* Game Overlay Styling */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
            border-radius: 20px;
            z-index: 10;
            pointer-events: none; /* Allows clicks to pass through if not visible */
        }
        
        .overlay-content {
            padding: 30px;
            background: #1f2937;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }
        
        .overlay-content h2 {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .overlay-content p {
            font-size: 1.2rem;
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div class="game-container">
        
        <!-- Game State Overlay (Hidden by default) -->
        <div id="gameOverlay" class="game-overlay" style="display: none;">
            <div class="overlay-content">
                <h2 id="overlayTitle">PAUSED</h2>
                <p id="overlayMessage">Press ESC to Resume</p>
                <p id="overlayScore"></p>
            </div>
        </div>

        <!-- Scoreboard -->
        <div class="scoreboard">
            <div id="score-p1" class="player-info">P1 (Red): 0</div>
            <div id="score-p2" class="player-info">P2 (Blue): 0</div>
        </div>

        <!-- Game Canvas -->
        <canvas id="handballCanvas" width="800" height="500"></canvas>

        <!-- Controls Information -->
        <div class="controls-info">
            <p><strong>Player 1 (Red):</strong> Move (W, A, S, D), **Dash (Left Shift)**.</p>
            <p><strong>Player 2 (Blue):</strong> Move (Arrows), **Dash (Right Control)**.</p>
            <p>Press **ESC** to Pause/Resume. (The game now runs indefinitely!)</p>
        </div>
    </div>

    <script>
        // Game Constants and Initialization
        const canvas = document.getElementById('handballCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('gameOverlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const overlayScore = document.getElementById('overlayScore');
        // Removed: timerDisplay variable

        // Dimensions
        const COURT_WIDTH = 800; // Fixed internal logic size
        const COURT_HEIGHT = 500;
        const PLAYER_RADIUS = 20;
        const BALL_RADIUS = 12;
        const GOAL_WIDTH = 30;
        const GOAL_HEIGHT = 160;

        // Game Timing Constants
        const FPS = 60;
        const frameTime = 1000 / FPS;
        const PAUSE_KEY = 'Escape';

        // Dash Constants
        const DASH_SPEED_MULTIPLIER = 2.5;
        const DASH_DURATION_FRAMES = 15; // 0.25 seconds
        const DASH_COOLDOWN_FRAMES = 180; // 3 seconds

        // Game State
        let score = { p1: 0, p2: 0 };
        let isGameRunning = false;
        let isPaused = false;
        // Removed: timeRemaining variable
        let lastTime = 0;

        // Player Factory (to easily create player objects with dash properties)
        const createPlayer = (x, y, color, keys, dashKey, isP1) => ({
            x, y,
            radius: PLAYER_RADIUS,
            color,
            baseColor: color,
            speed: 5,
            vx: 0,
            vy: 0,
            keys,
            dashKey,
            dashTimer: 0,
            cooldownTimer: 0,
            isP1
        });

        // --- Game Objects ---
        let player1 = createPlayer(
            COURT_WIDTH * 0.25, COURT_HEIGHT / 2, '#ef4444', 
            { up: 'w', down: 's', left: 'a', right: 'd' }, 
            'Shift', true
        );

        let player2 = createPlayer(
            COURT_WIDTH * 0.75, COURT_HEIGHT / 2, '#3b82f6', 
            { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, 
            'Control', false
        );

        let ball = {
            x: COURT_WIDTH / 2,
            y: COURT_HEIGHT / 2,
            radius: BALL_RADIUS,
            color: '#fcd34d',
            vx: 0,
            vy: 0,
            friction: 0.99,
            maxSpeed: 10
        };

        // Input
        let keysPressed = {};
        
        // --- Audio Context for simple sounds ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Simple Sound Generator (Beep)
        function playBeep(frequency = 440, duration = 0.1, volume = 0.5) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- Core Functions ---

        function setupGame() {
            // Event listeners for input
            window.addEventListener('keydown', (e) => { 
                keysPressed[e.key] = true; 
                // Handle Pause
                if (e.key === PAUSE_KEY) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', (e) => { keysPressed[e.key] = false; });
            
            // Start the game loop
            isGameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            // Removed: timeRemaining check
            isPaused = !isPaused;
            if (isPaused) {
                overlayTitle.textContent = "PAUSED";
                overlayMessage.textContent = "Press ESC to Resume";
                overlayScore.textContent = "";
                overlay.style.display = 'flex';
                playBeep(220, 0.2, 0.5);
            } else {
                overlay.style.display = 'none';
                lastTime = performance.now(); // Reset lastTime to prevent huge delta on resume
            }
        }
        
        function endGame() {
            // This function is no longer called automatically, but kept for manual triggering if needed.
            isGameRunning = false;
            let winner = 'TIE!';
            let winnerColor = '#fcd34d'; // Yellow
            
            if (score.p1 > score.p2) {
                winner = 'Player 1 (Red) WINS!';
                winnerColor = player1.baseColor;
            } else if (score.p2 > score.p1) {
                winner = 'Player 2 (Blue) WINS!';
                winnerColor = player2.baseColor;
            }
            
            overlayTitle.textContent = "GAME OVER";
            overlayTitle.style.color = winnerColor;
            overlayMessage.textContent = winner;
            overlayScore.textContent = `Final Score: Red ${score.p1} - ${score.p2} Blue`;
            overlay.style.display = 'flex';
            playBeep(100, 1.0, 0.9); // Low, long tone for end game
        }

        function resetBall(scorer) {
            ball.x = COURT_WIDTH / 2;
            ball.y = COURT_HEIGHT / 2;
            ball.vx = 0;
            ball.vy = 0;

            // Give a slight kick to the non-scorer
            if (scorer === player1) {
                ball.vx = 4;
            } else if (scorer === player2) {
                ball.vx = -4;
            }
            
            player1.x = COURT_WIDTH * 0.25;
            player1.y = COURT_HEIGHT / 2;
            player2.x = COURT_WIDTH * 0.75;
            player2.y = COURT_HEIGHT / 2;
            player1.vx = player1.vy = 0;
            player2.vx = player2.vy = 0;
        }

        function updateScoreboard() {
            document.getElementById('score-p1').textContent = `P1 (Red): ${score.p1}`;
            document.getElementById('score-p2').textContent = `P2 (Blue): ${score.p2}`;
        }
        
        // Removed: formatTime function
        // Removed: updateTimer function


        // --- Drawing ---

        function drawCourt() {
            // Center Line and Circle (as before)
            ctx.beginPath();
            ctx.moveTo(COURT_WIDTH / 2, 0);
            ctx.lineTo(COURT_WIDTH / 2, COURT_HEIGHT);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.arc(COURT_WIDTH / 2, COURT_HEIGHT / 2, 50, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            // Goal Areas
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;

            // Left Goal Area (P1 Side)
            ctx.beginPath();
            ctx.rect(5, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();

            // Right Goal Area (P2 Side)
            ctx.beginPath();
            ctx.rect(COURT_WIDTH - 105, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();
        }

        function drawGoal(x, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2, GOAL_WIDTH, GOAL_HEIGHT);
        }

        function drawPlayer(player) {
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            // Use the current color (which flashes during dash)
            ctx.fillStyle = player.color; 
            ctx.shadowBlur = 10;
            ctx.shadowColor = player.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
            
            // Draw Cooldown indicator
            if (player.cooldownTimer > 0) {
                ctx.beginPath();
                const progress = player.cooldownTimer / DASH_COOLDOWN_FRAMES;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (2 * Math.PI * progress);
                ctx.arc(player.x, player.y, player.radius + 5, startAngle, endAngle);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = ball.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#0d1a33';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, COURT_WIDTH, COURT_HEIGHT);

            // 1. Draw Court Markings
            drawCourt();

            // 2. Draw Goals
            drawGoal(0, '#880000'); // Left (P1 goal)
            drawGoal(COURT_WIDTH - GOAL_WIDTH, '#000088'); // Right (P2 goal)

            // 3. Draw Players and Ball
            drawPlayer(player1);
            drawPlayer(player2);
            drawBall();
        }

        // --- Logic ---
        
        function updatePlayerState(player) {
            // Handle Dash Cooldown and Duration
            if (player.cooldownTimer > 0) player.cooldownTimer--;

            // Check for Dash Activation
            if (keysPressed[player.dashKey] && player.cooldownTimer === 0) {
                player.dashTimer = DASH_DURATION_FRAMES;
                player.cooldownTimer = DASH_COOLDOWN_FRAMES;
                playBeep(880, 0.05, 0.7); // Dash sound
            }

            // Apply Dash Speed/Visuals
            if (player.dashTimer > 0) {
                player.speed = 5 * DASH_SPEED_MULTIPLIER;
                player.dashTimer--;
                // Flashing effect during dash
                player.color = player.dashTimer % 4 < 2 ? player.baseColor : '#ffffff'; 
            } else {
                player.speed = 5;
                player.color = player.baseColor; 
            }
        }

        function handleInput(player) {
            player.vx = 0;
            player.vy = 0;
            let moved = false;

            if (keysPressed[player.keys.up]) { player.vy = -player.speed; moved = true; }
            if (keysPressed[player.keys.down]) { player.vy = player.speed; moved = true; }
            if (keysPressed[player.keys.left]) { player.vx = -player.speed; moved = true; }
            if (keysPressed[player.keys.right]) { player.vx = player.speed; moved = true; }
            
            // Normalize diagonal movement speed
            if (moved && player.vx !== 0 && player.vy !== 0) {
                const diagSpeed = player.speed / Math.sqrt(2);
                player.vx = player.vx > 0 ? diagSpeed : -diagSpeed;
                player.vy = player.vy > 0 ? diagSpeed : -diagSpeed;
            }

            // Apply movement
            player.x += player.vx;
            player.y += player.vy;

            // Player boundary and half-court constraint
            const halfCourt = COURT_WIDTH / 2;
            const minX = player.radius;
            const maxX = COURT_WIDTH - player.radius;
            const minY = player.radius;
            const maxY = COURT_HEIGHT - player.radius;

            // Horizontal boundary (Court walls + Half-court)
            if (player.isP1) {
                player.x = Math.max(minX, Math.min(halfCourt - player.radius / 2, player.x));
            } else {
                player.x = Math.max(halfCourt + player.radius / 2, Math.min(maxX, player.x));
            }

            // Vertical boundary (Court walls)
            player.y = Math.max(minY, Math.min(maxY, player.y));
        }

        function updateBall() {
            // 1. Apply friction and move
            ball.vx *= ball.friction;
            ball.vy *= ball.friction;
            
            // Limit max speed
            let speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > ball.maxSpeed) {
                ball.vx = (ball.vx / speed) * ball.maxSpeed;
                ball.vy = (ball.vy / speed) * ball.maxSpeed;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;

            // 2. Wall Collision (Ball)
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > COURT_WIDTH) {
                ball.vx *= -1;
                ball.x = Math.max(ball.radius, Math.min(COURT_WIDTH - ball.radius, ball.x)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > COURT_HEIGHT) {
                ball.vy *= -1;
                ball.y = Math.max(ball.radius, Math.min(COURT_HEIGHT - ball.radius, ball.y)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
        }

        // Ball-Player Collision (Basic Impulse/Push)
        function checkBallPlayerCollision(player) {
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = ball.radius + player.radius;
            const minDistanceSquared = minDistance * minDistance;

            if (distanceSquared < minDistanceSquared) {
                playBeep(350, 0.08, 0.6);

                // Calculate the overlap
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;

                // Push the ball away to resolve collision
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Apply movement to resolve overlap
                ball.x += normalX * overlap * 1.05; 
                ball.y += normalY * overlap * 1.05;

                // Calculate the push vector based on player's current speed
                const playerMovementSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                // Push strength is scaled by the player's current speed, especially high if dashing
                let pushStrength = 1.0 + (playerMovementSpeed / 5); 
                
                // If dashing, make the push much stronger
                if (player.dashTimer > 0) {
                    pushStrength *= 1.5;
                }

                // Apply new velocity to the ball (elastic collision approximation)
                ball.vx = normalX * pushStrength * 8;
                ball.vy = normalY * pushStrength * 8;
            }
        }

        // Goal Check
        function checkGoal() {
            const goalTop = COURT_HEIGHT / 2 - GOAL_HEIGHT / 2;
            const goalBottom = COURT_HEIGHT / 2 + GOAL_HEIGHT / 2;

            // Left Goal (Player 2 scores)
            if (ball.x - ball.radius <= GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p2++;
                updateScoreboard();
                resetBall(player2);
                playBeep(600, 0.5, 0.8); 
                return true;
            }

            // Right Goal (Player 1 scores)
            if (ball.x + ball.radius >= COURT_WIDTH - GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p1++;
                updateScoreboard();
                resetBall(player1);
                playBeep(600, 0.5, 0.8); 
                return true;
            }
            return false;
        }


        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (!isGameRunning) return;

            const deltaTime = currentTime - lastTime;
            
            // Only update game state if not paused
            if (!isPaused) {
                // 1. Update Player States (Dash cooldown/duration)
                updatePlayerState(player1);
                updatePlayerState(player2);

                // 2. Handle Input & Player Movement
                handleInput(player1);
                handleInput(player2);

                // 3. Update Ball Position and Physics
                updateBall();

                // 4. Collision Checks
                checkBallPlayerCollision(player1);
                checkBallPlayerCollision(player2);

                // 5. Goal Check
                checkGoal();

                // Removed: updateTimer(deltaTime) call
            }

            // 6. Draw Everything (even if paused, to show the static paused screen)
            drawGame();

            lastTime = currentTime;

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game on window load
        window.onload = function() {
            // Set up the responsive canvas size based on parent container
            const container = document.querySelector('.game-container');
            const aspectRatio = COURT_WIDTH / COURT_HEIGHT;
            let w = container.clientWidth * 0.9;
            let h = w / aspectRatio;

            if (h > window.innerHeight * 0.8) {
                h = window.innerHeight * 0.8;
                w = h * aspectRatio;
            }
            
            // Ensure canvas is set to the logical dimensions for drawing, 
            // the CSS will handle the visible scaling.
            canvas.width = COURT_WIDTH; 
            canvas.height = COURT_HEIGHT; 
            
            updateScoreboard();
            setupGame();
        };

    </script>
</body>
</html>
