<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handball Court Game</title>
    <style>
        /*
        Global Styling
        */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1e3a8a, #0c4a6e); /* Deep Blue Gradient */
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            user-select: none;
            overflow: hidden; /* Prevent scrolling */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            background-color: #0d1a33; /* Dark background for score/info */
            position: relative; /* Needed for absolute positioning of overlay */
        }

        /*
        Canvas Styling
        */
        canvas {
            display: block;
            border: 4px solid #ffffff;
            border-radius: 10px;
            background-color: #22c55e; /* Vibrant Green Court */
            touch-action: none; /* Disable default touch actions */
            max-width: 95vw;
            max-height: 80vh;
        }

        /*
        Scoreboard and Info Styling
        */
        .scoreboard {
            display: flex;
            justify-content: space-between; 
            width: 100%;
            max-width: 800px;
            margin-bottom: 15px;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .player-info {
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            min-width: 150px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s;
            font-size: 1.5rem; 
        }

        #score-p1 { background-color: #ef4444; } /* Red */
        #score-p2 { background-color: #3b82f6; } /* Blue */
        
        .controls-info {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .controls-info strong {
            color: #fcd34d;
        }
        
        /* Reset Button Styling */
        .reset-button {
            background-color: #f59e0b; /* Amber */
            color: #0d1a33;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            align-self: center;
        }

        .reset-button:hover {
            background-color: #d97706; /* Darker amber */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
        }

        .reset-button:active {
            transform: scale(0.98);
        }

        /* Game Overlay Styling */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(5px);
            border-radius: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .overlay-content {
            padding: 30px;
            background: #1f2937;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
        }
        
        .overlay-content h2 {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .overlay-content p {
            font-size: 1.2rem;
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div class="game-container">
        
        <!-- Game State Overlay (Hidden by default) -->
        <div id="gameOverlay" class="game-overlay" style="display: none;">
            <div class="overlay-content">
                <h2 id="overlayTitle">PAUSED</h2>
                <p id="overlayMessage">Press ESC to Resume</p>
                <p id="overlayScore"></p>
            </div>
        </div>

        <!-- Scoreboard -->
        <div class="scoreboard">
            <div id="score-p1" class="player-info">P1 (Red): 0</div>
            <!-- Reset Button -->
            <button id="resetButton" class="reset-button">RESET GAME</button> 
            <div id="score-p2" class="player-info">P2 (Blue): 0</div>
        </div>

        <!-- Game Canvas -->
        <canvas id="handballCanvas" width="800" height="500"></canvas>

        <!-- Controls Information -->
        <div class="controls-info">
            <p><strong>Player 1 (Red):</strong> Move (W, A, S, D), **Dash (Left Shift)**, **Shield (X)**, **Super Shot (Z)**.</p>
            <p><strong>Player 2 (Blue):</strong> Move (Arrows), **Dash (Right Control)**, **Shield (9)**, **Super Shot (0)**.</p>
            <p>Dashing into an opponent will briefly **Stun** them. **Shield** prevents stun/knockback.</p>
            <p>Super Shot meter charges on hit. Press **ESC** to Pause/Resume.</p>
        </div>
    </div>

    <script>
        // Game Constants and Initialization
        const canvas = document.getElementById('handballCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('gameOverlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const overlayScore = document.getElementById('overlayScore');
        
        // Dimensions
        const COURT_WIDTH = 800; // Fixed internal logic size
        const COURT_HEIGHT = 500;
        const PLAYER_RADIUS = 20;
        const BALL_RADIUS = 12;
        const GOAL_WIDTH = 30;
        const GOAL_HEIGHT = 160;

        // Game Timing Constants
        const FPS = 60;
        const PAUSE_KEY = 'Escape';

        // Dash and Stun Constants
        const DASH_SPEED_MULTIPLIER = 2.5;
        const DASH_DURATION_FRAMES = 15; // 0.25 seconds
        const DASH_COOLDOWN_FRAMES = 180; // 3 seconds
        const STUN_DURATION_FRAMES = 30; // 0.5 seconds

        // Powerup Constants
        const POWERUP_RADIUS = 15;
        const POWERUP_DURATION_FRAMES = 300; // 5 seconds
        const POWERUP_SPAWN_COOLDOWN = 600; // 10 seconds before next spawn attempt

        // Goalie Zone Constants
        const GOALIE_ZONE_DEPTH = 150; 
        const GOALIE_SPEED_BONUS = 2; // +2 to speed when in zone
        
        // NEW: Super Shot Constants
        const SS_MAX_METER = 100;
        const SS_CHARGE_PER_HIT = 5; // Charge 5 points per hit
        const SS_SHOT_MULTIPLIER = 30; // Max velocity of 30, much faster than maxSpeed
        
        // NEW: Shield Constants
        const SHIELD_DURATION_FRAMES = 60; // 1 second
        const SHIELD_COOLDOWN_FRAMES = 360; // 6 seconds

        // NEW: Screen Shake Constants
        let shakeDuration = 0;
        const SHAKE_DURATION_FRAMES = 30; // 0.5 seconds
        const SHAKE_INTENSITY = 8; // Max shake displacement in pixels

        // Game State
        let score = { p1: 0, p2: 0 };
        let isGameRunning = false;
        let isPaused = false;
        let lastTime = 0;
        let lastTouchedBy = null; // Tracks player object that last hit the ball

        let powerup = { 
            x: 0, y: 0,
            active: false,
            durationTimer: 0,
            spawnTimer: 0
        };

        // Player Factory 
        const createPlayer = (x, y, color, keys, dashKey, shieldKey, ssKey, isP1) => ({
            x, y,
            radius: PLAYER_RADIUS,
            color,
            baseColor: color,
            speed: 5,
            vx: 0,
            vy: 0,
            keys,
            dashKey,
            shieldKey,          // NEW
            ssKey,              // NEW
            dashTimer: 0,
            cooldownTimer: 0,
            stunTimer: 0,
            boostTimer: 0, 
            shieldTimer: 0,     // NEW
            shieldCooldown: 0,  // NEW
            ssMeter: 0,         // NEW
            ssActive: false,    // NEW - true for one frame after pressing SS key
            isP1
        });

        // --- Game Objects ---
        let player1 = createPlayer(
            COURT_WIDTH * 0.25, COURT_HEIGHT / 2, '#ef4444', 
            { up: 'w', down: 's', left: 'a', right: 'd' }, 
            'Shift', 'x', 'z', true // dashKey, shieldKey, ssKey
        );

        let player2 = createPlayer(
            COURT_WIDTH * 0.75, COURT_HEIGHT / 2, '#3b82f6', 
            { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' }, 
            'Control', '9', '0', false // dashKey, shieldKey, ssKey
        );

        let ball = {
            x: COURT_WIDTH / 2,
            y: COURT_HEIGHT / 2,
            radius: BALL_RADIUS,
            color: '#fcd34d',
            vx: 0,
            vy: 0,
            friction: 0.99,
            maxSpeed: 15 
        };

        // Input
        let keysPressed = {};
        
        // --- Audio Context for simple sounds ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        // Simple Sound Generator (Beep)
        function playBeep(frequency = 440, duration = 0.1, volume = 0.5) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            gainNode.gain.value = volume;

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- Core Functions ---

        function setupGame() {
            // Event listeners for input
            window.addEventListener('keydown', (e) => { 
                keysPressed[e.key] = true; 
                if (e.key === PAUSE_KEY) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', (e) => { 
                keysPressed[e.key] = false; 
                // Ensure Super Shot key is only registered once per press
                if (e.key.toLowerCase() === player1.ssKey.toLowerCase()) player1.ssActive = false;
                if (e.key === player2.ssKey) player2.ssActive = false;
            });
            
            // Reset Button Listener
            document.getElementById('resetButton').addEventListener('click', resetGame);
            
            isGameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                overlayTitle.textContent = "PAUSED";
                overlayMessage.textContent = "Press ESC to Resume";
                overlayScore.textContent = "";
                overlay.style.display = 'flex';
                playBeep(220, 0.2, 0.5);
            } else {
                overlay.style.display = 'none';
                lastTime = performance.now();
            }
        }
        
        function resetGame() {
            score = { p1: 0, p2: 0 };
            lastTouchedBy = null;
            isPaused = false;
            isGameRunning = true;
            shakeDuration = 0;
            
            // Clear powerup
            powerup.active = false;
            powerup.spawnTimer = 0;
            
            // Reset players and ball position
            resetBall(null); 
            
            // Clear all active effects
            [player1, player2].forEach(p => {
                p.stunTimer = 0;
                p.dashTimer = 0;
                p.cooldownTimer = 0;
                p.boostTimer = 0;
                p.shieldTimer = 0;
                p.shieldCooldown = 0;
                p.ssMeter = 0;
                p.ssActive = false;
                p.color = p.baseColor;
            });

            overlay.style.display = 'none';
            
            updateScoreboard();
            playBeep(440, 0.3, 0.7);
            
            if (isGameRunning) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        function resetBall(scorer) {
            ball.x = COURT_WIDTH / 2;
            ball.y = COURT_HEIGHT / 2;
            ball.vx = 0;
            ball.vy = 0;

            // Give a slight kick to the non-scorer
            if (scorer === player1) {
                ball.vx = 4;
            } else if (scorer === player2) {
                ball.vx = -4;
            }
            
            player1.x = COURT_WIDTH * 0.25;
            player1.y = COURT_HEIGHT / 2;
            player2.x = COURT_WIDTH * 0.75;
            player2.y = COURT_HEIGHT / 2;
            player1.vx = player1.vy = 0;
            player2.vx = player2.vy = 0;
        }

        function updateScoreboard() {
            document.getElementById('score-p1').textContent = `P1 (Red): ${score.p1}`;
            document.getElementById('score-p2').textContent = `P2 (Blue): ${score.p2}`;
        }


        // --- Drawing ---

        function drawCourt() {
            // Draw Goalie Zones (visual aid)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, GOALIE_ZONE_DEPTH, COURT_HEIGHT); // Left Zone
            ctx.fillRect(COURT_WIDTH - GOALIE_ZONE_DEPTH, 0, GOALIE_ZONE_DEPTH, COURT_HEIGHT); // Right Zone
            
            // Center Line and Circle
            ctx.beginPath();
            ctx.moveTo(COURT_WIDTH / 2, 0);
            ctx.lineTo(COURT_WIDTH / 2, COURT_HEIGHT);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.arc(COURT_WIDTH / 2, COURT_HEIGHT / 2, 50, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            // Goal Areas
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;

            // Left Goal Area (P1 Side)
            ctx.beginPath();
            ctx.rect(5, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();

            // Right Goal Area (P2 Side)
            ctx.beginPath();
            ctx.rect(COURT_WIDTH - 105, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2 - 5, 100, GOAL_HEIGHT + 10);
            ctx.stroke();
        }
        
        // Draw possession indicator
        function drawPossessionIndicator(player) {
            if (lastTouchedBy === player) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI * 2);
                ctx.strokeStyle = '#fcd34d'; // Yellow/Gold color for possession
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]); // Shimmer effect
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
                ctx.closePath();
            }
        }
        
        // Draw Powerup
        function drawPowerup() {
            if (!powerup.active) return;
            
            ctx.beginPath();
            ctx.arc(powerup.x, powerup.y, POWERUP_RADIUS, 0, Math.PI * 2);
            
            // Pulsing color effect
            ctx.fillStyle = powerup.durationTimer % 20 < 10 ? '#ffff00' : '#ffa500'; 
            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.fillStyle;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawGoal(x, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, COURT_HEIGHT / 2 - GOAL_HEIGHT / 2, GOAL_WIDTH, GOAL_HEIGHT);
        }

        function drawPlayer(player) {
            // Draw Shield effect first if active
            if (player.shieldTimer > 0) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#00aaff'; // Cyan blue shield
                ctx.lineWidth = 8;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00aaff';
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.closePath();
            }

            // Draw Player body
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color; 
            ctx.shadowBlur = player.dashTimer > 0 || player.stunTimer > 0 || player.boostTimer > 0 ? 15 : 10;
            ctx.shadowColor = player.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
            
            // Draw Super Shot Meter above player
            const meterY = player.y - player.radius - 15;
            const meterWidth = 40;
            const meterHeight = 8;
            const meterX = player.x - meterWidth / 2;
            
            // Draw empty bar
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
            
            // Draw charged bar
            const charge = player.ssMeter / SS_MAX_METER;
            const chargedWidth = meterWidth * charge;
            ctx.fillStyle = charge === 1 ? '#ffcc00' : '#888800'; // Yellow if full, Gold if active
            ctx.fillRect(meterX, meterY, chargedWidth, meterHeight);
            
            // Draw bar outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);

            // Draw Cooldown indicator (Dash)
            if (player.cooldownTimer > 0) {
                ctx.beginPath();
                const progress = player.cooldownTimer / DASH_COOLDOWN_FRAMES;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (2 * Math.PI * progress);
                ctx.arc(player.x, player.y, player.radius + 5, startAngle, endAngle);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw Cooldown indicator (Shield)
            if (player.shieldCooldown > 0) {
                ctx.beginPath();
                const progress = player.shieldCooldown / SHIELD_COOLDOWN_FRAMES;
                const startAngle = -Math.PI / 2;
                const endAngle = startAngle + (2 * Math.PI * progress);
                ctx.arc(player.x, player.y, player.radius + 5, -Math.PI / 2 - Math.PI / 4, -Math.PI / 2 + Math.PI / 4); // Draw only top left/right arc
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = ball.color;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#0d1a33';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, COURT_WIDTH, COURT_HEIGHT);

            // 1. Draw Court Markings and Zones
            drawCourt();

            // 2. Draw Goals
            drawGoal(0, '#880000'); // Left (P1 goal)
            drawGoal(COURT_WIDTH - GOAL_WIDTH, '#000088'); // Right (P2 goal)

            // 3. Draw Powerup
            drawPowerup();

            // 4. Draw Players, Possession, and Ball
            drawPossessionIndicator(player1);
            drawPossessionIndicator(player2);
            drawPlayer(player1);
            drawPlayer(player2);
            drawBall();
        }

        // --- Logic ---
        
        function updatePlayerState(player) {
            // 0. Handle Shield Timers
            if (player.shieldCooldown > 0) player.shieldCooldown--;
            if (player.shieldTimer > 0) {
                player.shieldTimer--;
            }

            // 1. Handle Stun Timer (MUST run first, as it overrides movement)
            if (player.stunTimer > 0) {
                player.stunTimer--;
                player.color = player.stunTimer % 4 < 2 ? '#ffffff' : player.baseColor; // Flashing stun effect
                player.speed = 0; // Stunned players cannot move
                return; // Stop any further movement or dash checks
            }
            
            // 2. Handle Boost Timer
            let currentBaseSpeed = 5; // Default speed
            if (player.boostTimer > 0) {
                player.boostTimer--;
                currentBaseSpeed = 7; // Boosted speed
                player.color = player.boostTimer % 20 < 10 ? '#00ff00' : player.baseColor; // Green flash
            } else {
                player.color = player.baseColor; // Reset if boost runs out
            }
            
            // 3. Apply Goalie Zone Speed Boost (overrides color, but keeps speed if dashing)
            let inGoalieZone = false;
            if (player.isP1 && player.x < GOALIE_ZONE_DEPTH) {
                inGoalieZone = true;
            } else if (!player.isP1 && player.x > COURT_WIDTH - GOALIE_ZONE_DEPTH) {
                inGoalieZone = true;
            }
            
            if (inGoalieZone) {
                player.speed = currentBaseSpeed + GOALIE_SPEED_BONUS;
                // Subtle color change for Goalie Zone
                const zoneColor = player.isP1 ? '#ffaaaa' : '#aaaaff'; 
                player.color = zoneColor; 
            } else {
                player.speed = currentBaseSpeed; // Restore normal speed/boosted speed
            }


            // 4. Handle Dash Cooldown and Duration
            if (player.cooldownTimer > 0) player.cooldownTimer--;

            // Check for Dash Activation
            if (keysPressed[player.dashKey] && player.cooldownTimer === 0) {
                player.dashTimer = DASH_DURATION_FRAMES;
                player.cooldownTimer = DASH_COOLDOWN_FRAMES;
                playBeep(880, 0.05, 0.7); // Dash sound
            }

            // Apply Dash Speed/Visuals (overrides zone speed/color)
            if (player.dashTimer > 0) {
                player.speed = currentBaseSpeed * DASH_SPEED_MULTIPLIER;
                player.dashTimer--;
                // Flashing effect during dash
                player.color = player.dashTimer % 4 < 2 ? player.baseColor : '#ffffff'; 
            } 
            
            // NEW: Handle Super Shot activation
            if (keysPressed[player.ssKey] && player.ssMeter >= SS_MAX_METER && !player.ssActive) {
                player.ssActive = true;
                playBeep(1500, 0.1, 1.0); // High pitch activation sound
            }
            
            // NEW: Handle Shield activation
            if (keysPressed[player.shieldKey] && player.shieldCooldown === 0) {
                player.shieldTimer = SHIELD_DURATION_FRAMES;
                player.shieldCooldown = SHIELD_COOLDOWN_FRAMES;
                playBeep(100, 0.1, 0.5); // Low shield activation sound
            }
        }

        function handleInput(player) {
            // Player is stunned OR shielded, ignore movement input but allow SS/Shield activation 
            if (player.stunTimer > 0 || player.shieldTimer > 0) {
                player.vx = 0;
                player.vy = 0;
                // If shielded, freeze velocity for maximum defensive stability
                if (player.shieldTimer > 0) {
                    // Prevent movement entirely but allow player to block overlap
                } else {
                     return; // If stunned and not shielded, skip movement entirely
                }
            }

            player.vx = 0;
            player.vy = 0;
            let moved = false;

            if (keysPressed[player.keys.up]) { player.vy = -player.speed; moved = true; }
            if (keysPressed[player.keys.down]) { player.vy = player.speed; moved = true; }
            if (keysPressed[player.keys.left]) { player.vx = -player.speed; moved = true; }
            if (keysPressed[player.keys.right]) { player.vx = player.speed; moved = true; }
            
            // Normalize diagonal movement speed
            if (moved && player.vx !== 0 && player.vy !== 0) {
                const diagSpeed = player.speed / Math.sqrt(2);
                player.vx = player.vx > 0 ? diagSpeed : -diagSpeed;
                player.vy = player.vy > 0 ? diagSpeed : -diagSpeed;
            }

            // Apply movement
            player.x += player.vx;
            player.y += player.vy;

            // Player boundary and half-court constraint
            const halfCourt = COURT_WIDTH / 2;
            const minX = player.radius;
            const maxX = COURT_WIDTH - player.radius;
            const minY = player.radius;
            const maxY = COURT_HEIGHT - player.radius;

            // Horizontal boundary (Court walls + Half-court)
            if (player.isP1) {
                player.x = Math.max(minX, Math.min(halfCourt - player.radius / 2, player.x));
            } else {
                player.x = Math.max(halfCourt + player.radius / 2, Math.min(maxX, player.x));
            }

            // Vertical boundary (Court walls)
            player.y = Math.max(minY, Math.min(maxY, player.y));
        }
        
        // Player vs Player Collision (Stun Logic)
        function checkPlayerCollision(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = p1.radius + p2.radius;
            const minDistanceSquared = minDistance * minDistance;

            if (distanceSquared < minDistanceSquared) {
                // Collision detected: Resolve overlap first
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;
                const normalX = dx / distance;
                const normalY = dy / distance;

                p1.x += normalX * overlap / 2;
                p1.y += normalY * overlap / 2;
                p2.x -= normalX * overlap / 2;
                p2.y -= normalY * overlap / 2;
                
                // Stun/Knockback Logic
                const p1IsDashing = p1.dashTimer > 0;
                const p2IsDashing = p2.dashTimer > 0;
                const p1IsShielded = p1.shieldTimer > 0; // NEW
                const p2IsShielded = p2.shieldTimer > 0; // NEW
                
                // If a player is shielded, they cannot be stunned, but they can still stun others if dashing
                if (p1IsDashing && !p2IsShielded) {
                    // P1 hits P2 while dashing: P2 gets stunned
                    p2.stunTimer = STUN_DURATION_FRAMES;
                    playBeep(150, 0.3, 0.9); 
                } else if (p2IsDashing && !p1IsShielded) {
                    // P2 hits P1 while dashing: P1 gets stunned
                    p1.stunTimer = STUN_DURATION_FRAMES;
                    playBeep(150, 0.3, 0.9); 
                } else if (p1IsDashing && p2IsDashing) {
                    // Both dashing: minor stun/clash effect for the *unshielded* one(s)
                    if (!p1IsShielded) p1.stunTimer = Math.floor(STUN_DURATION_FRAMES / 2);
                    if (!p2IsShielded) p2.stunTimer = Math.floor(STUN_DURATION_FRAMES / 2);
                    playBeep(500, 0.1, 0.5); 
                }
            }
        }

        // Powerup Logic (Kept from previous version)
        function spawnPowerup() {
            if (powerup.active || isPaused) return;

            if (powerup.spawnTimer > 0) {
                powerup.spawnTimer--;
                return;
            }

            // Attempt to spawn powerup after cooldown
            if (Math.random() < 0.005) { 
                // Spawn powerup in the center area, away from goal zones
                powerup.x = Math.random() * (COURT_WIDTH - 2 * GOALIE_ZONE_DEPTH) + GOALIE_ZONE_DEPTH; 
                powerup.y = Math.random() * (COURT_HEIGHT - 2 * POWERUP_RADIUS - 50) + 25;
                powerup.active = true;
                powerup.durationTimer = POWERUP_DURATION_FRAMES;
                powerup.spawnTimer = 0; 
                playBeep(1000, 0.1, 0.4); 
            }
        }
        
        function updatePowerup() {
            if (powerup.active) {
                powerup.durationTimer--;
                if (powerup.durationTimer <= 0) {
                    powerup.active = false;
                    powerup.spawnTimer = POWERUP_SPAWN_COOLDOWN; 
                    playBeep(100, 0.1, 0.3); 
                }
            } else if (powerup.spawnTimer > 0) {
                 powerup.spawnTimer--;
            }
        }

        function checkPowerupCollection(player) {
            if (!powerup.active) return;

            const dx = player.x - powerup.x;
            const dy = player.y - powerup.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = player.radius + POWERUP_RADIUS;

            if (distanceSquared < minDistance * minDistance) {
                // Collected! Grant boost and reset powerup
                player.boostTimer += POWERUP_DURATION_FRAMES;
                powerup.active = false;
                powerup.spawnTimer = POWERUP_SPAWN_COOLDOWN; 
                powerup.durationTimer = 0;
                playBeep(1200, 0.2, 0.9); 
            }
        }


        function updateBall() {
            // 1. Apply friction and move
            ball.vx *= ball.friction;
            ball.vy *= ball.friction;
            
            // Limit max speed
            let speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > ball.maxSpeed) {
                ball.vx = (ball.vx / speed) * ball.maxSpeed;
                ball.vy = (ball.vy / speed) * ball.maxSpeed;
            }

            ball.x += ball.vx;
            ball.y += ball.vy;

            // 2. Wall Collision (Ball)
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > COURT_WIDTH) {
                ball.vx *= -1;
                ball.x = Math.max(ball.radius, Math.min(COURT_WIDTH - ball.radius, ball.x)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > COURT_HEIGHT) {
                ball.vy *= -1;
                ball.y = Math.max(ball.radius, Math.min(COURT_HEIGHT - ball.radius, ball.y)); // Clamp
                playBeep(200, 0.05, 0.4);
            }
        }

        // Ball-Player Collision (Basic Impulse/Push)
        function checkBallPlayerCollision(player) {
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = ball.radius + player.radius;
            const minDistanceSquared = minDistance * minDistance;

            if (distanceSquared < minDistanceSquared) {
                playBeep(350, 0.08, 0.6);
                
                // Update possession and charge Super Shot
                lastTouchedBy = player;
                player.ssMeter = Math.min(SS_MAX_METER, player.ssMeter + SS_CHARGE_PER_HIT);

                // Calculate the overlap
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;

                // Push the ball away to resolve collision
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Apply movement to resolve overlap
                ball.x += normalX * overlap * 1.05; 
                ball.y += normalY * overlap * 1.05;

                // Calculate the push vector based on player's current speed
                const playerMovementSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                
                // Base push strength (higher base for more aggressive play)
                let pushStrength = 4.0; 
                
                // Apply modifiers
                if (player.dashTimer > 0) {
                    pushStrength *= 2.5; 
                } else if (playerMovementSpeed > 0) {
                    pushStrength += (playerMovementSpeed / player.speed) * 3;
                }
                
                // NEW: Super Shot Logic
                if (player.ssActive) {
                    pushStrength = SS_SHOT_MULTIPLIER;
                    player.ssMeter = 0; // Drain meter
                    player.ssActive = false; // Deactivate shot
                    playBeep(2000, 0.3, 1.0); // Extreme shot sound
                }

                // NEW: Shield Logic (makes player act like a rigid wall, deflecting)
                if (player.shieldTimer > 0) {
                    // Shield hit is purely defensive, medium strength, no movement bonus
                    pushStrength = 8.0; 
                }

                // Apply new velocity to the ball (elastic collision approximation)
                ball.vx = normalX * pushStrength;
                ball.vy = normalY * pushStrength;
            }
        }

        // Goal Check
        function checkGoal() {
            const goalTop = COURT_HEIGHT / 2 - GOAL_HEIGHT / 2;
            const goalBottom = COURT_HEIGHT / 2 + GOAL_HEIGHT / 2;
            let goalScored = false;

            // Left Goal (Player 2 scores)
            if (ball.x - ball.radius <= GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p2++;
                resetBall(player2);
                goalScored = true;
            }

            // Right Goal (Player 1 scores)
            if (ball.x + ball.radius >= COURT_WIDTH - GOAL_WIDTH && ball.y > goalTop && ball.y < goalBottom) {
                score.p1++;
                resetBall(player1);
                goalScored = true;
            }

            if (goalScored) {
                updateScoreboard();
                shakeDuration = SHAKE_DURATION_FRAMES; // NEW: Activate screen shake
                playBeep(600, 0.5, 0.8); 
                lastTouchedBy = null; 
            }
            return goalScored;
        }


        // --- Game Loop ---
        function gameLoop(currentTime) {
            if (!isGameRunning) return;

            // Screen Shake Logic (NEW)
            let offsetX = 0;
            let offsetY = 0;
            if (shakeDuration > 0) {
                offsetX = (Math.random() - 0.5) * SHAKE_INTENSITY * (shakeDuration / SHAKE_DURATION_FRAMES);
                offsetY = (Math.random() - 0.5) * SHAKE_INTENSITY * (shakeDuration / SHAKE_DURATION_FRAMES);
                shakeDuration--;
            }
            
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY); // Apply transformation for shake

            // Only update game state if not paused
            if (!isPaused) {
                // 1. Update Player States (Dash cooldown/duration/stun/boost/shield)
                updatePlayerState(player1);
                updatePlayerState(player2);

                // 2. Handle Input & Player Movement
                handleInput(player1);
                handleInput(player2);

                // 3. Powerup Management
                spawnPowerup();
                updatePowerup();

                // 4. Update Ball Position and Physics
                updateBall();

                // 5. Collision Checks
                checkBallPlayerCollision(player1);
                checkBallPlayerCollision(player2);
                checkPlayerCollision(player1, player2); 
                checkPowerupCollection(player1); 
                checkPowerupCollection(player2);

                // 6. Goal Check
                checkGoal();
            }

            // 7. Draw Everything
            drawGame();

            // Reset transformation matrix after drawing (crucial for normal rendering next frame)
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            lastTime = currentTime;

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game on window load
        window.onload = function() {
            // Set up the canvas size (using logical size 800x500 for internal math)
            canvas.width = COURT_WIDTH; 
            canvas.height = COURT_HEIGHT; 
            
            updateScoreboard();
            setupGame();
        };

    </script>
</body>
</html>
